{
  "updatedAt": "2025-12-24T09:32:10.732Z",
  "createdAt": "2025-12-23T09:30:18.636Z",
  "id": "Gu9mVRTwvJCq0Fpf",
  "name": "Capture_Projection",
  "description": null,
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1600,
        704
      ],
      "id": "trigger-capture-projection",
      "name": "ExecuteWorkflowTrigger"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Determine emoji based on projection type and prepare for routing\nconst ctx = $json.ctx;\nconst projectionType = ctx.projection?.type || 'note';\n\nconst emojiMap = {\n  'activity': '\ud83d\udd18',\n  'note': '\ud83d\udcdd',\n  'todo': '\u2705'\n};\n\nconst emoji = emojiMap[projectionType] || '\ud83d\udcdd';\n\nreturn {\n  json: {\n    ctx: ctx,\n    projection_type: projectionType,\n    emoji: emoji,\n    inference_start: Date.now()\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1376,
        704
      ],
      "id": "prepare-routing",
      "name": "PrepareRouting"
    },
    {
      "parameters": {
        "method": "DELETE",
        "url": "=https://discord.com/api/v10/channels/{{ $json.ctx.event.channel_id }}/messages/{{ $json.ctx.event.message_id }}/reactions/\ud83d\udd35/@me",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "discordBotApi",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1152,
        912
      ],
      "id": "remove-blue-reaction",
      "name": "Remove\ud83d\udd35Reaction",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000,
      "credentials": {
        "discordBotApi": {
          "id": "HzhURrgtJQZuwPMZ",
          "name": "Discord Bot account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=https://discord.com/api/v10/channels/{{ $json.ctx.event.channel_id }}/messages/{{ $json.ctx.event.message_id }}/reactions/{{ encodeURIComponent($json.emoji) }}/@me",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "discordBotApi",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1152,
        496
      ],
      "id": "add-type-reaction",
      "name": "AddTypeReaction",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000,
      "credentials": {
        "discordBotApi": {
          "id": "HzhURrgtJQZuwPMZ",
          "name": "Discord Bot account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "is-activity",
                    "leftValue": "={{ $json.projection_type }}",
                    "rightValue": "activity",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "activity"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "is-note",
                    "leftValue": "={{ $json.projection_type }}",
                    "rightValue": "note",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "note"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "is-todo",
                    "leftValue": "={{ $json.projection_type }}",
                    "rightValue": "todo",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "todo"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "route-by-type",
      "name": "RouteByType",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        -1152,
        688
      ]
    },
    {
      "parameters": {
        "jsCode": "// Mock LLM Chain node: ActivityClassifier\nconst input = $input.first().json;\nconst inputText = input.ctx?.event?.clean_text \n  || input.text \n  || input.prompt \n  || \"\";\n\n// Check for specific keywords to provide more realistic mocks\nlet response = \"[MOCK LLM] I processed your request.\";\n\nif (inputText.includes(\"!!\") || inputText.toLowerCase().includes(\"act\")) {\n  response = \"[MOCK LLM] Activity recorded: \" + inputText.replace(/!!|act/i, \"\").trim();\n} else if (inputText.includes(\"..\") || inputText.toLowerCase().includes(\"note\")) {\n  response = \"[MOCK LLM] Note saved.\";\n} else if (inputText.includes(\"$$\") || inputText.toLowerCase().includes(\"todo\")) {\n  response = \"[MOCK LLM] Added to your todo list.\";\n} else if (inputText.includes(\"++\")) {\n  response = \"[MOCK LLM] I am starting a new thread for you. How can I help?\";\n} else if (inputText.includes(\"--\")) {\n  response = \"[MOCK LLM] Thread summarized and closed.\";\n}\n\nreturn [{ \n  json: { \n    text: response,\n    _mock: true,\n    _original_node: \"ActivityClassifier\",\n    _input_preview: inputText.substring(0, 200)\n  } \n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -928,
        496
      ],
      "id": "activity-classifier",
      "name": "ActivityClassifier"
    },
    {
      "parameters": {
        "jsCode": "// Mock LLM Chain node: NoteClassifier\nconst input = $input.first().json;\nconst inputText = input.ctx?.event?.clean_text \n  || input.text \n  || input.prompt \n  || \"\";\n\n// Check for specific keywords to provide more realistic mocks\nlet response = \"[MOCK LLM] I processed your request.\";\n\nif (inputText.includes(\"!!\") || inputText.toLowerCase().includes(\"act\")) {\n  response = \"[MOCK LLM] Activity recorded: \" + inputText.replace(/!!|act/i, \"\").trim();\n} else if (inputText.includes(\"..\") || inputText.toLowerCase().includes(\"note\")) {\n  response = \"[MOCK LLM] Note saved.\";\n} else if (inputText.includes(\"$$\") || inputText.toLowerCase().includes(\"todo\")) {\n  response = \"[MOCK LLM] Added to your todo list.\";\n} else if (inputText.includes(\"++\")) {\n  response = \"[MOCK LLM] I am starting a new thread for you. How can I help?\";\n} else if (inputText.includes(\"--\")) {\n  response = \"[MOCK LLM] Thread summarized and closed.\";\n}\n\nreturn [{ \n  json: { \n    text: response,\n    _mock: true,\n    _original_node: \"NoteClassifier\",\n    _input_preview: inputText.substring(0, 200)\n  } \n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -928,
        704
      ],
      "id": "note-classifier",
      "name": "NoteClassifier"
    },
    {
      "parameters": {
        "jsCode": "// Mock LLM Chain node: TodoClassifier\nconst input = $input.first().json;\nconst inputText = input.ctx?.event?.clean_text \n  || input.text \n  || input.prompt \n  || \"\";\n\n// Check for specific keywords to provide more realistic mocks\nlet response = \"[MOCK LLM] I processed your request.\";\n\nif (inputText.includes(\"!!\") || inputText.toLowerCase().includes(\"act\")) {\n  response = \"[MOCK LLM] Activity recorded: \" + inputText.replace(/!!|act/i, \"\").trim();\n} else if (inputText.includes(\"..\") || inputText.toLowerCase().includes(\"note\")) {\n  response = \"[MOCK LLM] Note saved.\";\n} else if (inputText.includes(\"$$\") || inputText.toLowerCase().includes(\"todo\")) {\n  response = \"[MOCK LLM] Added to your todo list.\";\n} else if (inputText.includes(\"++\")) {\n  response = \"[MOCK LLM] I am starting a new thread for you. How can I help?\";\n} else if (inputText.includes(\"--\")) {\n  response = \"[MOCK LLM] Thread summarized and closed.\";\n}\n\nreturn [{ \n  json: { \n    text: response,\n    _mock: true,\n    _original_node: \"TodoClassifier\",\n    _input_preview: inputText.substring(0, 200)\n  } \n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -928,
        896
      ],
      "id": "todo-classifier",
      "name": "TodoClassifier"
    },
    {
      "parameters": {
        "model": "xiaomi/mimo-v2-flash:free",
        "options": {
          "timeout": 10000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -928,
        1296
      ],
      "id": "mimo-v2-flash",
      "name": "MimoV2Flash",
      "credentials": {
        "openRouterApi": {
          "id": "nB20cMgvlwePo3oC",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "model": "nvidia/nemotron-nano-9b-v2:free",
        "options": {
          "timeout": 10000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -784,
        1232
      ],
      "id": "nemotron-nano-9b",
      "name": "NemotronNano9b",
      "credentials": {
        "openRouterApi": {
          "id": "nB20cMgvlwePo3oC",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "mode": "append",
        "numberInputs": 2
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -576,
        688
      ],
      "id": "merge-classifiers",
      "name": "MergeClassifiers"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Parse LLM classification output and build query for Execute_Queries\nconst llmText = $json.text?.trim() || '';\nconst routingItem = $('PrepareRouting').first().json;\nconst ctx = routingItem.ctx;\nconst projectionType = routingItem.projection_type;\nconst inferenceStart = routingItem.inference_start;\nconst durationMs = Date.now() - inferenceStart;\n\n// Format trace_chain for PostgreSQL uuid[] type\nconst traceChain = ctx.event.trace_chain || [];\nconst traceChainPg = '{' + traceChain.join(',') + '}';\n\n// Get voided projection IDs from correction context (if this is a correction)\nconst voidedProjectionIds = ctx.correction?.voided_projection_ids || [];\nconst voidedProjectionIdsPg = voidedProjectionIds.length > 0 \n  ? '{' + voidedProjectionIds.join(',') + '}' \n  : null;\n\n// Default categories/priorities per type\nconst defaults = {\n  activity: 'work',\n  note: 'reflection',\n  todo: 'medium'\n};\n\n// Parse scores from LLM output\nconst scores = {};\nlet topResult = null;\nlet topScore = 0;\n\ntry {\n  const lines = llmText.split('\\n').filter(line => line.includes('|'));\n  lines.forEach(line => {\n    const [key, scoreStr] = line.split('|').map(s => s.trim());\n    const score = parseInt(scoreStr);\n    if (!isNaN(score)) {\n      scores[key] = score;\n      if (score > topScore) {\n        topScore = score;\n        topResult = key;\n      }\n    }\n  });\n} catch (e) {\n  // Use default on parse error\n}\n\nif (!topResult) {\n  topResult = defaults[projectionType];\n  topScore = 50;\n}\n\n// Build projection data based on type\nlet projectionData;\nif (projectionType === 'activity') {\n  projectionData = {\n    timestamp: new Date().toISOString(),\n    category: topResult,\n    description: ctx.event.clean_text,\n    message_url: ctx.event.message_url,\n    confidence: topScore / 100,\n    all_scores: scores\n  };\n} else if (projectionType === 'note') {\n  projectionData = {\n    timestamp: new Date().toISOString(),\n    category: topResult,\n    text: ctx.event.clean_text,\n    message_url: ctx.event.message_url,\n    confidence: topScore / 100,\n    all_scores: scores\n  };\n} else if (projectionType === 'todo') {\n  projectionData = {\n    timestamp: new Date().toISOString(),\n    priority: topResult,\n    description: ctx.event.clean_text,\n    message_url: ctx.event.message_url,\n    confidence: topScore / 100,\n    all_scores: scores,\n    status: 'pending'\n  };\n}\n\nreturn {\n  json: {\n    ctx: {\n      ...ctx,\n      llm: {\n        result: topResult,\n        confidence: topScore / 100,\n        all_scores: scores,\n        completion_text: llmText,\n        duration_ms: durationMs\n      },\n      db_queries: [{\n        key: 'projection',\n        sql: `WITH new_trace AS (\n  INSERT INTO traces (event_id, step_name, data, trace_chain)\n  VALUES (\n    $1::uuid,\n    $2 || '_classification',\n    jsonb_build_object(\n      'input', jsonb_build_object('text', $3),\n      'completion', $4,\n      'result', jsonb_build_object(\n        'value', $5,\n        'confidence', $6::numeric,\n        'all_scores', $7::jsonb\n      ),\n      'model', 'xiaomi/mimo-v2-flash:free',\n      'duration_ms', $8::integer\n    ),\n    $9::uuid[]\n  )\n  RETURNING id, event_id\n),\nnew_projection AS (\n  INSERT INTO projections (\n    trace_id,\n    event_id,\n    trace_chain,\n    projection_type,\n    data,\n    status,\n    timezone,\n    supersedes_projection_id\n  )\n  SELECT\n    new_trace.id,\n    new_trace.event_id,\n    $9::uuid[] || new_trace.id,\n    $2,\n    $10::jsonb,\n    'auto_confirmed',\n    $11,\n    CASE WHEN $12::uuid[] IS NOT NULL AND array_length($12::uuid[], 1) > 0 THEN ($12::uuid[])[1] ELSE NULL END\n  FROM new_trace\n  RETURNING *\n),\nupdate_voided AS (\n  UPDATE projections\n  SET superseded_by_projection_id = (SELECT id FROM new_projection)\n  WHERE id = ANY($12::uuid[])\n  RETURNING id\n)\nSELECT np.*, COALESCE((SELECT array_agg(id) FROM update_voided), ARRAY[]::uuid[]) as linked_voided_ids\nFROM new_projection np;`,\n        params: [\n          ctx.event.event_id,\n          projectionType,\n          ctx.event.clean_text,\n          llmText,\n          topResult,\n          topScore / 100,\n          JSON.stringify(scores),\n          durationMs,\n          traceChainPg,\n          JSON.stringify(projectionData),\n          ctx.event.timezone,\n          voidedProjectionIdsPg\n        ]\n      }]\n    },\n    projection_type: projectionType,\n    projection_data: projectionData\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -352,
        704
      ],
      "id": "parse-classification",
      "name": "ParseClassification"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "CgUAxK0i4YhrZ2Wp",
          "mode": "list",
          "cachedResultName": "Execute_Queries",
          "cachedResultUrl": "/workflow/CgUAxK0i4YhrZ2Wp"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "ctx": "={{ $json.ctx }}"
          }
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        -128,
        704
      ],
      "id": "store-projection",
      "name": "StoreProjection"
    },
    {
      "parameters": {
        "jsCode": "// Mock Discord node: LogToKaironLogs\n// Returns fake Discord API response for dev testing\nconst input = $input.first().json;\nreturn [{ \n  json: { \n    id: \"mock-discord-\" + Date.now(),\n    channel_id: input.channelId || \"mock-channel\",\n    content: input.content || \"\",\n    success: true,\n    _mock: true,\n    _original_node: \"LogToKaironLogs\"\n  } \n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        96,
        704
      ],
      "id": "log-to-kairon-logs",
      "name": "LogToKaironLogs",
      "webhookId": "capture-projection-log",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract text for embedding from projection data\n// Activity uses 'description', Note/Todo use 'text'\nconst ctx = $json.ctx;\nconst projection = ctx.db?.projection?.row || {};\nconst data = projection.data || {};\nconst embeddingText = data.description || data.text || '';\n\nreturn {\n  json: {\n    projection_id: projection.id,\n    embedding_text: embeddingText\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        96,
        496
      ],
      "id": "prepare-embedding-text",
      "name": "PrepareEmbeddingText"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.EMBEDDING_SERVICE_URL }}/embed",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"texts\": [{{ JSON.stringify($json.embedding_text || '') }}]\n}",
        "options": {
          "timeout": 10000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        320,
        496
      ],
      "id": "embed-projection-text",
      "name": "EmbedProjectionText",
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build embedding insert query for Execute_Queries\nconst prepareData = $('PrepareEmbeddingText').first().json;\nconst embeddings = $json.embeddings;\n\n// Check if we have a valid embedding\nif (!embeddings || !embeddings[0]) {\n  return {};  // Skip if no embedding\n}\n\nconst embeddingVector = '[' + embeddings[0].join(',') + ']';\n\nreturn {\n  json: {\n    ctx: {\n      db_queries: [{\n        key: 'embedding',\n        sql: `-- Insert embedding for the projection (fire-and-forget)\nINSERT INTO embeddings (projection_id, model, embedding_data, embedded_text, embedding)\nSELECT \n  $1::uuid,\n  'all-MiniLM-L6-v2',\n  '{}',\n  $2,\n  $3::vector\nWHERE $3 IS NOT NULL\nON CONFLICT DO NOTHING;`,\n        params: [\n          prepareData.projection_id,\n          prepareData.embedding_text,\n          embeddingVector\n        ]\n      }]\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        496
      ],
      "id": "build-embedding-query",
      "name": "BuildEmbeddingQuery"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "CgUAxK0i4YhrZ2Wp",
          "mode": "list",
          "cachedResultName": "Execute_Queries",
          "cachedResultUrl": "/workflow/CgUAxK0i4YhrZ2Wp"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "ctx": "={{ $json.ctx }}"
          }
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        768,
        496
      ],
      "id": "insert-embedding",
      "name": "InsertEmbedding",
      "continueOnFail": true
    }
  ],
  "connections": {
    "ExecuteWorkflowTrigger": {
      "main": [
        [
          {
            "node": "PrepareRouting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PrepareRouting": {
      "main": [
        [
          {
            "node": "RouteByType",
            "type": "main",
            "index": 0
          },
          {
            "node": "AddTypeReaction",
            "type": "main",
            "index": 0
          },
          {
            "node": "Remove\ud83d\udd35Reaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RouteByType": {
      "main": [
        [
          {
            "node": "ActivityClassifier",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "NoteClassifier",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "TodoClassifier",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "NoteClassifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ActivityClassifier": {
      "main": [
        [
          {
            "node": "MergeClassifiers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "NoteClassifier": {
      "main": [
        [
          {
            "node": "MergeClassifiers",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "TodoClassifier": {
      "main": [
        [
          {
            "node": "MergeClassifiers",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "MergeClassifiers": {
      "main": [
        [
          {
            "node": "ParseClassification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ParseClassification": {
      "main": [
        [
          {
            "node": "StoreProjection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "StoreProjection": {
      "main": [
        [
          {
            "node": "PrepareEmbeddingText",
            "type": "main",
            "index": 0
          },
          {
            "node": "LogToKaironLogs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PrepareEmbeddingText": {
      "main": [
        [
          {
            "node": "EmbedProjectionText",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "EmbedProjectionText": {
      "main": [
        [
          {
            "node": "BuildEmbeddingQuery",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BuildEmbeddingQuery": {
      "main": [
        [
          {
            "node": "InsertEmbedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MimoV2Flash": {
      "ai_languageModel": [
        [
          {
            "node": "ActivityClassifier",
            "type": "ai_languageModel",
            "index": 0
          }
        ],
        [
          {
            "node": "NoteClassifier",
            "type": "ai_languageModel",
            "index": 0
          }
        ],
        [
          {
            "node": "TodoClassifier",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "NemotronNano9b": {
      "ai_languageModel": [
        [
          {
            "node": "ActivityClassifier",
            "type": "ai_languageModel",
            "index": 1
          }
        ],
        [
          {
            "node": "NoteClassifier",
            "type": "ai_languageModel",
            "index": 1
          }
        ],
        [
          {
            "node": "TodoClassifier",
            "type": "ai_languageModel",
            "index": 1
          }
        ]
      ]
    }
  },
  "settings": {
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "NOJ7FqVhVLqw0n8D",
    "availableInMCP": false,
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": {
    "transformedForDev": true
  },
  "versionId": "ff0e1285-46be-426e-a39f-c5d22bde9ec3",
  "activeVersionId": null,
  "versionCounter": 187,
  "triggerCount": 0,
  "shared": [
    {
      "updatedAt": "2025-12-23T09:30:18.636Z",
      "createdAt": "2025-12-23T09:30:18.636Z",
      "role": "workflow:owner",
      "workflowId": "Gu9mVRTwvJCq0Fpf",
      "projectId": "erM3nntdLL53noWi",
      "project": {
        "updatedAt": "2025-12-23T09:23:39.658Z",
        "createdAt": "2025-12-23T09:16:56.460Z",
        "id": "erM3nntdLL53noWi",
        "name": "Chris Irineo <chriskevini@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "projectRelations": [
          {
            "updatedAt": "2025-12-23T09:16:56.460Z",
            "createdAt": "2025-12-23T09:16:56.460Z",
            "userId": "2a851a2d-b7e5-4b3c-aefb-6eaaa79e0659",
            "projectId": "erM3nntdLL53noWi",
            "user": {
              "updatedAt": "2025-12-24T08:40:46.063Z",
              "createdAt": "2025-12-23T09:16:54.881Z",
              "id": "2a851a2d-b7e5-4b3c-aefb-6eaaa79e0659",
              "email": "chriskevini@gmail.com",
              "firstName": "Chris",
              "lastName": "Irineo",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2025-12-23T09:23:43.723Z",
                "personalization_survey_n8n_version": "1.123.5"
              },
              "settings": {
                "userActivated": true,
                "firstSuccessfulWorkflowId": "CgUAxK0i4YhrZ2Wp",
                "userActivatedAt": 1766487000077,
                "easyAIWorkflowOnboarded": true
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2025-12-24",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": null
}