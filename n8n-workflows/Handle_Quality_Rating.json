{
  "name": "Handle_Quality_Rating",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -400,
        300
      ],
      "id": "trigger-quality-rating",
      "name": "ReceiveEvent"
    },
    {
      "parameters": {
        "jsCode": "// Parse quality rating from emoji\nconst ctx = $json.ctx;\nconst emoji = ctx.event.emoji;\n\n// Map emoji to quality score\nconst qualityMap = {\n  'ðŸ‘': 1.0,\n  'ðŸ‘Ž': 0.0\n};\n\nconst qualityScore = qualityMap[emoji];\n\nif (qualityScore === undefined) {\n  throw new Error(`Unknown quality emoji: ${emoji}`);\n}\n\nreturn {\n  json: {\n    ctx,\n    quality_score: qualityScore,\n    emoji\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -180,
        300
      ],
      "id": "parse-quality",
      "name": "ParseQualityRating"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Find projections by either the original user message or the bot reply message\nWITH target_projections AS (\n  -- Option 1: User message that triggered projections\n  SELECT p.id\n  FROM projections p\n  JOIN events e ON p.event_id = e.id\n  WHERE e.payload->>'discord_message_id' = $3\n    AND e.event_type = 'discord_message'\n    AND p.status IN ('auto_confirmed', 'confirmed')\n  UNION\n  -- Option 2: Bot reply message (projection stores the message ID)\n  SELECT p.id\n  FROM projections p\n  WHERE (p.data->>'discord_message_id' = $3\n     OR p.metadata->>'message_id' = $3)\n    AND p.status IN ('auto_confirmed', 'confirmed')\n)\nUPDATE projections\nSET \n  quality_score = $1,\n  metadata = COALESCE(metadata, '{}'::jsonb) || jsonb_build_object(\n    'quality_rated_at', NOW(),\n    'quality_emoji', $2\n  )\nWHERE id IN (SELECT id FROM target_projections)\nRETURNING id, projection_type, quality_score;",
        "options": {
          "values": "={{ [  $json.quality_score ,  $json.emoji ,  $json.ctx.event.message_id  ] }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        40,
        300
      ],
      "id": "update-quality-score",
      "name": "UpdateQualityScore",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Format response based on updated projections\nconst ctx = $('ReceiveEvent').first().json.ctx;\nconst qualityScore = $('ParseQualityRating').first().json.quality_score;\nconst emoji = $('ParseQualityRating').first().json.emoji;\nconst updated = $input.all();\n\nif (!updated || updated.length === 0 || !updated[0].json.id) {\n  return {\n    ctx,\n    response: {\n      content: `${emoji} No projections found for this message to rate.`\n    },\n    updated_count: 0\n  };\n}\n\nconst count = updated.length;\nconst types = [...new Set(updated.map(u => u.json.projection_type))];\nconst typeStr = types.join(', ');\nconst scoreLabel = qualityScore === 1.0 ? 'good' : 'poor';\n\nreturn {\n  ctx,\n  response: {\n    content: `${emoji} Marked ${count} projection(s) as **${scoreLabel}** quality (${typeStr})`\n  },\n  updated_count: count\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        260,
        300
      ],
      "id": "format-response",
      "name": "FormatResponse"
    },
    {
      "parameters": {
        "resource": "message",
        "guildId": {
          "__rl": true,
          "value": "={{ $json.ctx.event.guild_id }}",
          "mode": "id"
        },
        "channelId": {
          "__rl": true,
          "value": "={{ $json.ctx.event.channel_id }}",
          "mode": "id"
        },
        "content": "={{ $json.response.content }}",
        "options": {
          "messageReference": "={{ $json.ctx.event.message_id }}"
        }
      },
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        480,
        300
      ],
      "id": "send-response",
      "name": "SendResponse",
      "webhookId": "quality-rating-response",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000,
      "credentials": {
        "discordBotApi": {
          "name": "Discord Bot account"
        }
      }
    }
  ],
  "connections": {
    "ReceiveEvent": {
      "main": [
        [
          {
            "node": "ParseQualityRating",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ParseQualityRating": {
      "main": [
        [
          {
            "node": "UpdateQualityScore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "UpdateQualityScore": {
      "main": [
        [
          {
            "node": "FormatResponse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FormatResponse": {
      "main": [
        [
          {
            "node": "SendResponse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "NOJ7FqVhVLqw0n8D",
    "availableInMCP": false,
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "active": false
}
