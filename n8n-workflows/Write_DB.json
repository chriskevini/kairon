{
  "name": "Write_DB",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        0,
        0
      ],
      "id": "trigger-execute-write",
      "name": "Execute Workflow Trigger"
    },
    {
      "parameters": {
        "jsCode": "// Validate input and initialize loop state\nconst ctx = $json.ctx;\n\nif (!ctx?.db_writes || !Array.isArray(ctx.db_writes) || ctx.db_writes.length === 0) {\n  throw new Error('Write_DB requires ctx.db_writes array with at least one write operation');\n}\n\n// Validate each write has required fields\nfor (const w of ctx.db_writes) {\n  if (!w.key || !w.sql) {\n    throw new Error('Each write in ctx.db_writes must have key and sql fields');\n  }\n}\n\n// Initialize loop state\nreturn [{\n  json: {\n    original_ctx: ctx,\n    writes: ctx.db_writes,\n    current_index: 0,\n    results: {}  // Will accumulate {key: {row, rows, count}}\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        220,
        0
      ],
      "id": "initialize-loop",
      "name": "Initialize Loop"
    },
    {
      "parameters": {
        "jsCode": "// Prepare current write operation for execution\n// Supports $results.key.field references in params for chaining\n// Also formats arrays as PostgreSQL array literals when needed\nconst state = $json;\nconst write = state.writes[state.current_index];\n\n// Helper to format JS arrays as PostgreSQL array literals\nfunction formatPgArray(arr) {\n  if (!Array.isArray(arr)) return arr;\n  return '{' + arr.join(',') + '}';\n}\n\n// Process params to resolve $results references\nlet params = write.params || [];\n\nif (params.length > 0) {\n  params = params.map(param => {\n    if (typeof param === 'string' && param.startsWith('$results.')) {\n      // Parse reference like \"$results.trace.row.id\"\n      const path = param.substring('$results.'.length).split('.');\n      let value = state.results;\n      for (const key of path) {\n        if (value && typeof value === 'object') {\n          value = value[key];\n        } else {\n          value = undefined;\n          break;\n        }\n      }\n      if (value === undefined) {\n        throw new Error(`Write_DB: Could not resolve reference ${param}`);\n      }\n      // Auto-format arrays for PostgreSQL\n      return formatPgArray(value);\n    }\n    return param;\n  });\n}\n\nreturn [{\n  json: {\n    ...state,\n    current_write: write,\n    sql: write.sql,\n    params: params\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        440,
        0
      ],
      "id": "prepare-write",
      "name": "Prepare Write"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.sql }}",
        "options": {
          "queryReplacement": "={{ $json.params }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        660,
        0
      ],
      "id": "execute-postgres-write",
      "name": "Execute Write",
      "credentials": {
        "postgres": {
          "id": "MdnYzEgjzWRujz2v",
          "name": "Postgres account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "mode": "append",
        "numberInputs": 2,
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        880,
        0
      ],
      "id": "merge-results",
      "name": "Merge Results"
    },
    {
      "parameters": {
        "jsCode": "// Collect write results and check if more writes remain\nconst items = $input.all();\n\n// Find state from merge (has original_ctx)\nlet state = null;\nconst writeResults = [];\n\nfor (const item of items) {\n  if (item.json.original_ctx) {\n    state = item.json;\n  } else {\n    // This is a Postgres result row\n    writeResults.push(item.json);\n  }\n}\n\nif (!state) {\n  throw new Error('Write_DB: Lost loop state');\n}\n\n// Store results for current write\nconst currentKey = state.current_write.key;\nstate.results[currentKey] = {\n  row: writeResults[0] || null,  // First row (most common for RETURNING single row)\n  rows: writeResults,             // All rows\n  count: writeResults.length      // Row count\n};\n\n// Move to next write\nstate.current_index++;\n\n// Check if more writes remain\nconst hasMore = state.current_index < state.writes.length;\n\nreturn [{\n  json: {\n    ...state,\n    has_more: hasMore\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        0
      ],
      "id": "collect-results",
      "name": "Collect Results"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-more",
              "leftValue": "={{ $json.has_more }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1320,
        0
      ],
      "id": "check-more-writes",
      "name": "More Writes?"
    },
    {
      "parameters": {
        "jsCode": "// Restore ctx with all write results in ctx.db namespace\nconst state = $json;\n\n// Remove db_writes since it was consumed\nconst { db_writes, ...restCtx } = state.original_ctx;\n\nreturn [{\n  json: {\n    ctx: {\n      ...restCtx,\n      db: {\n        ...(restCtx.db || {}),\n        ...state.results\n      }\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1540,
        100
      ],
      "id": "finalize-context",
      "name": "Finalize Context"
    }
  ],
  "connections": {
    "Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Initialize Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Loop": {
      "main": [
        [
          {
            "node": "Prepare Write",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Write": {
      "main": [
        [
          {
            "node": "Execute Write",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Execute Write": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Results": {
      "main": [
        [
          {
            "node": "Collect Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Results": {
      "main": [
        [
          {
            "node": "More Writes?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "More Writes?": {
      "main": [
        [
          {
            "node": "Prepare Write",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Finalize Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "JOXLqn9TTznBdo7Q"
  },
  "staticData": null,
  "meta": null,
  "active": false
}
