{
  "name": "Capture_Projection",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1600,
        704
      ],
      "id": "trigger-capture-projection",
      "name": "Execute Workflow Trigger"
    },
    {
      "parameters": {
        "jsCode": "// Determine emoji based on projection type and prepare for routing\nconst ctx = $json.ctx;\nconst projectionType = ctx.projection?.type || 'note';\n\nconst emojiMap = {\n  'activity': 'ðŸ”˜',\n  'note': 'ðŸ“',\n  'todo': 'âœ…'\n};\n\nconst emoji = emojiMap[projectionType] || 'ðŸ“';\n\nreturn [{\n  json: {\n    ctx: ctx,\n    projection_type: projectionType,\n    emoji: emoji,\n    inference_start: Date.now()\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1376,
        704
      ],
      "id": "prepare-routing",
      "name": "Prepare Routing"
    },
    {
      "parameters": {
        "method": "DELETE",
        "url": "=https://discord.com/api/v10/channels/{{ $json.ctx.event.channel_id }}/messages/{{ $json.ctx.event.message_id }}/reactions/ðŸ”µ/@me",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "discordBotApi",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1152,
        912
      ],
      "id": "remove-blue-reaction",
      "name": "Remove ðŸ”µ Reaction",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000,
      "credentials": {
        "discordBotApi": {
          "id": "hvetTjtpeKFB1V0I",
          "name": "Discord Bot account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=https://discord.com/api/v10/channels/{{ $json.ctx.event.channel_id }}/messages/{{ $json.ctx.event.message_id }}/reactions/{{ encodeURIComponent($json.emoji) }}/@me",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "discordBotApi",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1152,
        496
      ],
      "id": "add-type-reaction",
      "name": "Add Type Reaction",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000,
      "credentials": {
        "discordBotApi": {
          "id": "hvetTjtpeKFB1V0I",
          "name": "Discord Bot account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "is-activity",
                    "leftValue": "={{ $json.projection_type }}",
                    "rightValue": "activity",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "activity"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "is-note",
                    "leftValue": "={{ $json.projection_type }}",
                    "rightValue": "note",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "note"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "is-todo",
                    "leftValue": "={{ $json.projection_type }}",
                    "rightValue": "todo",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "todo"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "route-by-type",
      "name": "Route by Type",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        -1152,
        688
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are an activity classifier for a life-tracking system.\n\nAssign probability scores (0-100) to each category. Scores must add up to exactly 100.\n\n## Categories\n\nwork â†’ Productive, focused effort on projects, coding, building, debugging, refining systems, testing, or task-oriented development.\nleisure â†’ Relaxed, non-productive enjoyment: scrolling, watching videos, browsing, casual reading, coffee breaks.\nstudy â†’ Intentional learning or skill-building not directly tied to immediate project work.\nhealth â†’ Physical or mental self-care: exercise, eating meals, hygiene, mindfulness.\nsleep â†’ Going to bed, waking up, napping, or sleep transitions.\nrelationships â†’ Social interaction: chatting with friends/family/partners, or personal/social AI conversations.\nadmin â†’ Organizational/maintenance tasks: planning schedules, managing todos, fixing tools/setup, meta work on tracking system.\n\n## Key Guidelines\n- Heavily favor the most dominant theme.\n- Sleep-related messages â†’ give sleep the highest score.\n- Project-related AI chats â†’ work.\n- Eating/drinking â†’ health (split with leisure if combined).\n- Meta work on tracking system â†’ admin (or work if core building).\n- Omit any category with score â‰¤5 (treat as 0).\n\nOutput ONLY lines for categories with score >5, in any order:\ncategory_name|X\n\n(Printed scores must sum to exactly 100, integers only)\n\n## Examples\nworking on the router agent implementation\nwork|98\nadmin|2\n\nsipping coffee while scrolling social media\nleisure|88\nhealth|12\n\ngoing to bed after a long day\nsleep|93\nhealth|7\n\nhaving lunch\nhealth|92\nleisure|8\n\n## Message to classify:\n{{ $json.ctx.event.clean_text }}",
        "needsFallback": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -928,
        496
      ],
      "id": "activity-classifier",
      "name": "Activity Classifier"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a note classifier for a life-tracking system.\n\nClassify notes into exactly 2 categories. Assign probability scores (0-100) that add up to exactly 100.\n\n# Categories\n\nfact â†’ External, objective, declarative knowledge about the world or people (birthdays, preferences, allergies, likes/dislikes, factual statements about others).\n\nreflection â†’ Internal, subjective knowledge (insights, decisions, observations, realizations, thoughts, self-analysis, patterns, emotional states, personal commitments).\n\n# The Core Distinction\n- fact = \"Things about the world/others\" (external reality)\n- reflection = \"Things about me/my mind\" (internal experience)\n\n# Key Guidelines\n- Declarative statements about others â†’ fact (\"John loves coffee\", \"Sarah is allergic to nuts\")\n- Dates, birthdays, preferences of others â†’ fact\n- Personal insights, realizations â†’ reflection (\"I work better in mornings\")\n- Decisions, commitments â†’ reflection (\"decided to switch to async\")\n- Self-observations â†’ reflection (\"I've been more focused lately\")\n- When in doubt: Is it about THEM or about ME? â†’ fact vs reflection\n\nOutput format (only lines with score >5):\ncategory_name|score\n\n(Scores must sum to exactly 100, integers only)\n\n# Examples\n\nJohn loves dark roast coffee\nfact|95\nreflection|5\n\nMom's birthday is June 12\nfact|98\nreflection|2\n\nnoticed an interesting pattern in my productivity\nreflection|94\nfact|6\n\nI work better in the mornings\nreflection|88\nfact|12\n\n## Message to classify:\n{{ $json.ctx.event.clean_text }}",
        "needsFallback": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -928,
        704
      ],
      "id": "note-classifier",
      "name": "Note Classifier"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a todo priority classifier for a life-tracking system.\n\nAssign probability scores (0-100) to each priority level. Scores must add up to exactly 100.\n\n# Priority Levels\n\nhigh â†’ Urgent, time-sensitive, blocking other work, or has significant consequences if delayed.\nmedium â†’ Important but not urgent, should be done soon, normal priority.\nlow â†’ Nice to have, can be deferred, no immediate impact if delayed.\n\n# Key Guidelines\n- Explicit urgency words (\"ASAP\", \"urgent\", \"today\", \"now\") â†’ high\n- Deadlines mentioned â†’ high if soon, medium if later\n- \"Should\", \"need to\", \"have to\" without urgency â†’ medium\n- \"Maybe\", \"sometime\", \"eventually\", \"would be nice\" â†’ low\n- Bug fixes, blockers â†’ high\n- Regular tasks, maintenance â†’ medium\n- Ideas, improvements, \"someday\" items â†’ low\n\nOutput format (only lines with score >5):\npriority_name|score\n\n(Scores must sum to exactly 100, integers only)\n\n# Examples\n\nneed to fix the auth bug before demo tomorrow\nhigh|92\nmedium|8\n\nshould update the documentation\nmedium|85\nlow|15\n\nmaybe add dark mode someday\nlow|88\nmedium|12\n\nurgent: server is down\nhigh|98\nmedium|2\n\n## Message to classify:\n{{ $json.ctx.event.clean_text }}",
        "needsFallback": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -928,
        896
      ],
      "id": "todo-classifier",
      "name": "Todo Classifier"
    },
    {
      "parameters": {
        "model": "xiaomi/mimo-v2-flash:free",
        "options": {
          "timeout": 10000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -928,
        1296
      ],
      "id": "mimo-v2-flash",
      "name": "mimo-v2-flash",
      "credentials": {
        "openRouterApi": {
          "id": "r79IBN16aZtPIN8T",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "model": "nvidia/nemotron-nano-9b-v2:free",
        "options": {
          "timeout": 10000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -784,
        1232
      ],
      "id": "nemotron-nano-9b",
      "name": "nemotron-nano-9b",
      "credentials": {
        "openRouterApi": {
          "id": "r79IBN16aZtPIN8T",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "mode": "append",
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -576,
        688
      ],
      "id": "merge-classifiers",
      "name": "Merge Classifiers"
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM classification output and prepare db_writes for Write_DB\nconst llmText = $json.text?.trim() || '';\nconst routingItem = $('Prepare Routing').first().json;\nconst ctx = routingItem.ctx;\nconst projectionType = routingItem.projection_type;\nconst inferenceStart = routingItem.inference_start;\nconst durationMs = Date.now() - inferenceStart;\n\n// Format trace_chain for PostgreSQL uuid[] type\nconst traceChain = ctx.event.trace_chain || [];\nconst traceChainPg = '{' + traceChain.join(',') + '}';\n\n// Get voided projection IDs from correction context (if this is a correction)\nconst voidedProjectionIds = ctx.correction?.voided_projection_ids || [];\nconst voidedProjectionIdsPg = voidedProjectionIds.length > 0 \n  ? '{' + voidedProjectionIds.join(',') + '}' \n  : null;\n\n// Default categories/priorities per type\nconst defaults = {\n  activity: 'work',\n  note: 'reflection',\n  todo: 'medium'\n};\n\n// Parse scores from LLM output\nconst scores = {};\nlet topResult = null;\nlet topScore = 0;\n\ntry {\n  const lines = llmText.split('\\n').filter(line => line.includes('|'));\n  lines.forEach(line => {\n    const [key, scoreStr] = line.split('|').map(s => s.trim());\n    const score = parseInt(scoreStr);\n    if (!isNaN(score)) {\n      scores[key] = score;\n      if (score > topScore) {\n        topScore = score;\n        topResult = key;\n      }\n    }\n  });\n} catch (e) {\n  // Use default on parse error\n}\n\nif (!topResult) {\n  topResult = defaults[projectionType];\n  topScore = 50;\n}\n\n// Build projection data based on type\nlet projectionData;\nif (projectionType === 'activity') {\n  projectionData = {\n    timestamp: new Date().toISOString(),\n    category: topResult,\n    description: ctx.event.clean_text,\n    message_url: ctx.event.message_url,\n    confidence: topScore / 100,\n    all_scores: scores\n  };\n} else if (projectionType === 'note') {\n  projectionData = {\n    timestamp: new Date().toISOString(),\n    category: topResult,\n    text: ctx.event.clean_text,\n    message_url: ctx.event.message_url,\n    confidence: topScore / 100,\n    all_scores: scores\n  };\n} else if (projectionType === 'todo') {\n  projectionData = {\n    timestamp: new Date().toISOString(),\n    priority: topResult,\n    description: ctx.event.clean_text,\n    message_url: ctx.event.message_url,\n    confidence: topScore / 100,\n    all_scores: scores,\n    status: 'pending'\n  };\n}\n\n// Build the combined SQL (CTE that does trace + projection + void update atomically)\nconst sql = `WITH new_trace AS (\n  INSERT INTO traces (event_id, step_name, data, trace_chain)\n  VALUES (\n    $1::uuid,\n    $2 || '_classification',\n    jsonb_build_object(\n      'input', jsonb_build_object('text', $3),\n      'completion', $4,\n      'result', jsonb_build_object(\n        'value', $5,\n        'confidence', $6::numeric,\n        'all_scores', $7::jsonb\n      ),\n      'model', 'xiaomi/mimo-v2-flash:free',\n      'duration_ms', $8::integer\n    ),\n    $9::uuid[]\n  )\n  RETURNING id, event_id\n),\nnew_projection AS (\n  INSERT INTO projections (\n    trace_id,\n    event_id,\n    trace_chain,\n    projection_type,\n    data,\n    status,\n    timezone,\n    supersedes_projection_id\n  )\n  SELECT\n    new_trace.id,\n    new_trace.event_id,\n    $9::uuid[] || new_trace.id,\n    $2,\n    $10::jsonb,\n    'auto_confirmed',\n    $11,\n    CASE WHEN $12::uuid[] IS NOT NULL AND array_length($12::uuid[], 1) > 0 THEN ($12::uuid[])[1] ELSE NULL END\n  FROM new_trace\n  RETURNING *\n),\nupdate_voided AS (\n  UPDATE projections\n  SET superseded_by_projection_id = (SELECT id FROM new_projection)\n  WHERE id = ANY($12::uuid[])\n  RETURNING id\n)\nSELECT np.*, COALESCE((SELECT array_agg(id) FROM update_voided), ARRAY[]::uuid[]) as linked_voided_ids\nFROM new_projection np`;\n\nreturn [{\n  json: {\n    ctx: {\n      ...ctx,\n      llm: {\n        result: topResult,\n        confidence: topScore / 100,\n        all_scores: scores,\n        completion_text: llmText,\n        duration_ms: durationMs\n      },\n      db_writes: [{\n        key: 'projection',\n        sql: sql,\n        params: [\n          ctx.event.event_id,\n          projectionType,\n          ctx.event.clean_text,\n          llmText,\n          topResult,\n          topScore / 100,\n          JSON.stringify(scores),\n          durationMs,\n          traceChainPg,\n          JSON.stringify(projectionData),\n          ctx.event.timezone,\n          voidedProjectionIdsPg\n        ]\n      }]\n    },\n    projection_type: projectionType\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -352,
        704
      ],
      "id": "parse-classification",
      "name": "Parse Classification"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "zgJX3AbUNUvDJa48"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "ctx": "={{ $json.ctx }}"
          }
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        -128,
        704
      ],
      "id": "write-db",
      "name": "Write DB"
    },
    {
      "parameters": {
        "resource": "message",
        "guildId": {
          "__rl": true,
          "value": "={{ $json.ctx.event.guild_id }}",
          "mode": "id"
        },
        "channelId": {
          "__rl": true,
          "value": "={{ $env.DISCORD_CHANNEL_KAIRON_LOGS }}",
          "mode": "id"
        },
        "content": "=**[{{ $('Parse Classification').item.json.projection_type.charAt(0).toUpperCase() + $('Parse Classification').item.json.projection_type.slice(1) }} Classification]**\n**Message:** {{ $json.ctx.event.clean_text }}\n**Result:** {{ $json.ctx.llm.result }}\n**Confidence:** [ {{ Object.entries($json.ctx.llm.all_scores || {}).sort((a, b) => b[1] - a[1]).map(([k, v]) => `${k}:${v}%`).join(' | ') }} ]",
        "options": {}
      },
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        96,
        704
      ],
      "id": "log-to-kairon-logs",
      "name": "Log to Kairon Logs",
      "webhookId": "capture-projection-log",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000,
      "credentials": {
        "discordBotApi": {
          "id": "hvetTjtpeKFB1V0I",
          "name": "Discord Bot account"
        }
      },
      "onError": "continueRegularOutput"
    }
  ],
  "connections": {
    "Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Prepare Routing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Routing": {
      "main": [
        [
          {
            "node": "Route by Type",
            "type": "main",
            "index": 0
          },
          {
            "node": "Add Type Reaction",
            "type": "main",
            "index": 0
          },
          {
            "node": "Remove ðŸ”µ Reaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Type": {
      "main": [
        [
          {
            "node": "Activity Classifier",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Note Classifier",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Todo Classifier",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Note Classifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Activity Classifier": {
      "main": [
        [
          {
            "node": "Merge Classifiers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Note Classifier": {
      "main": [
        [
          {
            "node": "Merge Classifiers",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Todo Classifier": {
      "main": [
        [
          {
            "node": "Merge Classifiers",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Merge Classifiers": {
      "main": [
        [
          {
            "node": "Parse Classification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Classification": {
      "main": [
        [
          {
            "node": "Write DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write DB": {
      "main": [
        [
          {
            "node": "Log to Kairon Logs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "mimo-v2-flash": {
      "ai_languageModel": [
        [
          {
            "node": "Activity Classifier",
            "type": "ai_languageModel",
            "index": 0
          }
        ],
        [
          {
            "node": "Note Classifier",
            "type": "ai_languageModel",
            "index": 0
          }
        ],
        [
          {
            "node": "Todo Classifier",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "nemotron-nano-9b": {
      "ai_languageModel": [
        [
          {
            "node": "Activity Classifier",
            "type": "ai_languageModel",
            "index": 1
          }
        ],
        [
          {
            "node": "Note Classifier",
            "type": "ai_languageModel",
            "index": 1
          }
        ],
        [
          {
            "node": "Todo Classifier",
            "type": "ai_languageModel",
            "index": 1
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "JOXLqn9TTznBdo7Q"
  },
  "staticData": null,
  "meta": null,
  "active": false
}
