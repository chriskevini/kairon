{
  "name": "Capture_Projection",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1600,
        704
      ],
      "id": "trigger-capture-projection",
      "name": "Execute Workflow Trigger"
    },
    {
      "parameters": {
        "jsCode": "// Determine emoji based on projection type and prepare for routing\nconst ctx = $json.ctx;\nconst projectionType = ctx.projection?.type || 'note';\n\nconst emojiMap = {\n  'activity': '\ud83d\udd18',\n  'note': '\ud83d\udcdd',\n  'todo': '\u2705'\n};\n\nconst emoji = emojiMap[projectionType] || '\ud83d\udcdd';\n\nreturn [{\n  json: {\n    ctx: ctx,\n    projection_type: projectionType,\n    emoji: emoji,\n    inference_start: Date.now()\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1376,
        704
      ],
      "id": "prepare-routing",
      "name": "Prepare Routing"
    },
    {
      "parameters": {
        "method": "DELETE",
        "url": "=https://discord.com/api/v10/channels/{{ $json.ctx.event.channel_id }}/messages/{{ $json.ctx.event.message_id }}/reactions/\ud83d\udd35/@me",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "discordBotApi",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1152,
        912
      ],
      "id": "remove-blue-reaction",
      "name": "Remove \ud83d\udd35 Reaction",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000,
      "credentials": {
        "discordBotApi": {
          "id": "hvetTjtpeKFB1V0I",
          "name": "Discord Bot account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=https://discord.com/api/v10/channels/{{ $json.ctx.event.channel_id }}/messages/{{ $json.ctx.event.message_id }}/reactions/{{ encodeURIComponent($json.emoji) }}/@me",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "discordBotApi",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1152,
        496
      ],
      "id": "add-type-reaction",
      "name": "Add Type Reaction",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000,
      "credentials": {
        "discordBotApi": {
          "id": "hvetTjtpeKFB1V0I",
          "name": "Discord Bot account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "is-activity",
                    "leftValue": "={{ $json.projection_type }}",
                    "rightValue": "activity",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "activity"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "is-note",
                    "leftValue": "={{ $json.projection_type }}",
                    "rightValue": "note",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "note"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "is-todo",
                    "leftValue": "={{ $json.projection_type }}",
                    "rightValue": "todo",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "todo"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "route-by-type",
      "name": "Route by Type",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        -1152,
        688
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are an activity classifier for a life-tracking system.\n\nAssign probability scores (0-100) to each category. Scores must add up to exactly 100.\n\n## Categories\n\nwork \u2192 Productive, focused effort on projects, coding, building, debugging, refining systems, testing, or task-oriented development.\nleisure \u2192 Relaxed, non-productive enjoyment: scrolling, watching videos, browsing, casual reading, coffee breaks.\nstudy \u2192 Intentional learning or skill-building not directly tied to immediate project work.\nhealth \u2192 Physical or mental self-care: exercise, eating meals, hygiene, mindfulness.\nsleep \u2192 Going to bed, waking up, napping, or sleep transitions.\nrelationships \u2192 Social interaction: chatting with friends/family/partners, or personal/social AI conversations.\nadmin \u2192 Organizational/maintenance tasks: planning schedules, managing todos, fixing tools/setup, meta work on tracking system.\n\n## Key Guidelines\n- Heavily favor the most dominant theme.\n- Sleep-related messages \u2192 give sleep the highest score.\n- Project-related AI chats \u2192 work.\n- Eating/drinking \u2192 health (split with leisure if combined).\n- Meta work on tracking system \u2192 admin (or work if core building).\n- Omit any category with score \u22645 (treat as 0).\n\nOutput ONLY lines for categories with score >5, in any order:\ncategory_name|X\n\n(Printed scores must sum to exactly 100, integers only)\n\n## Examples\nworking on the router agent implementation\nwork|98\nadmin|2\n\nsipping coffee while scrolling social media\nleisure|88\nhealth|12\n\ngoing to bed after a long day\nsleep|93\nhealth|7\n\nhaving lunch\nhealth|92\nleisure|8\n\n## Message to classify:\n{{ $json.ctx.event.clean_text }}",
        "needsFallback": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -928,
        496
      ],
      "id": "activity-classifier",
      "name": "Activity Classifier"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a note classifier for a life-tracking system.\n\nClassify notes into exactly 2 categories. Assign probability scores (0-100) that add up to exactly 100.\n\n# Categories\n\nfact \u2192 External, objective, declarative knowledge about the world or people (birthdays, preferences, allergies, likes/dislikes, factual statements about others).\n\nreflection \u2192 Internal, subjective knowledge (insights, decisions, observations, realizations, thoughts, self-analysis, patterns, emotional states, personal commitments).\n\n# The Core Distinction\n- fact = \"Things about the world/others\" (external reality)\n- reflection = \"Things about me/my mind\" (internal experience)\n\n# Key Guidelines\n- Declarative statements about others \u2192 fact (\"John loves coffee\", \"Sarah is allergic to nuts\")\n- Dates, birthdays, preferences of others \u2192 fact\n- Personal insights, realizations \u2192 reflection (\"I work better in mornings\")\n- Decisions, commitments \u2192 reflection (\"decided to switch to async\")\n- Self-observations \u2192 reflection (\"I've been more focused lately\")\n- When in doubt: Is it about THEM or about ME? \u2192 fact vs reflection\n\nOutput format (only lines with score >5):\ncategory_name|score\n\n(Scores must sum to exactly 100, integers only)\n\n# Examples\n\nJohn loves dark roast coffee\nfact|95\nreflection|5\n\nMom's birthday is June 12\nfact|98\nreflection|2\n\nnoticed an interesting pattern in my productivity\nreflection|94\nfact|6\n\nI work better in the mornings\nreflection|88\nfact|12\n\n## Message to classify:\n{{ $json.ctx.event.clean_text }}",
        "needsFallback": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -928,
        704
      ],
      "id": "note-classifier",
      "name": "Note Classifier"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a todo priority classifier for a life-tracking system.\n\nAssign probability scores (0-100) to each priority level. Scores must add up to exactly 100.\n\n# Priority Levels\n\nhigh \u2192 Urgent, time-sensitive, blocking other work, or has significant consequences if delayed.\nmedium \u2192 Important but not urgent, should be done soon, normal priority.\nlow \u2192 Nice to have, can be deferred, no immediate impact if delayed.\n\n# Key Guidelines\n- Explicit urgency words (\"ASAP\", \"urgent\", \"today\", \"now\") \u2192 high\n- Deadlines mentioned \u2192 high if soon, medium if later\n- \"Should\", \"need to\", \"have to\" without urgency \u2192 medium\n- \"Maybe\", \"sometime\", \"eventually\", \"would be nice\" \u2192 low\n- Bug fixes, blockers \u2192 high\n- Regular tasks, maintenance \u2192 medium\n- Ideas, improvements, \"someday\" items \u2192 low\n\nOutput format (only lines with score >5):\npriority_name|score\n\n(Scores must sum to exactly 100, integers only)\n\n# Examples\n\nneed to fix the auth bug before demo tomorrow\nhigh|92\nmedium|8\n\nshould update the documentation\nmedium|85\nlow|15\n\nmaybe add dark mode someday\nlow|88\nmedium|12\n\nurgent: server is down\nhigh|98\nmedium|2\n\n## Message to classify:\n{{ $json.ctx.event.clean_text }}",
        "needsFallback": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -928,
        896
      ],
      "id": "todo-classifier",
      "name": "Todo Classifier"
    },
    {
      "parameters": {
        "model": "xiaomi/mimo-v2-flash:free",
        "options": {
          "timeout": 10000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -928,
        1296
      ],
      "id": "mimo-v2-flash",
      "name": "mimo-v2-flash",
      "credentials": {
        "openRouterApi": {
          "id": "r79IBN16aZtPIN8T",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "model": "nvidia/nemotron-nano-9b-v2:free",
        "options": {
          "timeout": 10000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -784,
        1232
      ],
      "id": "nemotron-nano-9b",
      "name": "nemotron-nano-9b",
      "credentials": {
        "openRouterApi": {
          "id": "r79IBN16aZtPIN8T",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "mode": "append",
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -576,
        688
      ],
      "id": "merge-classifiers",
      "name": "Merge Classifiers"
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM classification output and build query for Execute_Queries\nconst llmText = $json.text?.trim() || '';\nconst routingItem = $('Prepare Routing').first().json;\nconst ctx = routingItem.ctx;\nconst projectionType = routingItem.projection_type;\nconst inferenceStart = routingItem.inference_start;\nconst durationMs = Date.now() - inferenceStart;\n\n// Format trace_chain for PostgreSQL uuid[] type\nconst traceChain = ctx.event.trace_chain || [];\nconst traceChainPg = '{' + traceChain.join(',') + '}';\n\n// Get voided projection IDs from correction context (if this is a correction)\nconst voidedProjectionIds = ctx.correction?.voided_projection_ids || [];\nconst voidedProjectionIdsPg = voidedProjectionIds.length > 0 \n  ? '{' + voidedProjectionIds.join(',') + '}' \n  : null;\n\n// Default categories/priorities per type\nconst defaults = {\n  activity: 'work',\n  note: 'reflection',\n  todo: 'medium'\n};\n\n// Parse scores from LLM output\nconst scores = {};\nlet topResult = null;\nlet topScore = 0;\n\ntry {\n  const lines = llmText.split('\\n').filter(line => line.includes('|'));\n  lines.forEach(line => {\n    const [key, scoreStr] = line.split('|').map(s => s.trim());\n    const score = parseInt(scoreStr);\n    if (!isNaN(score)) {\n      scores[key] = score;\n      if (score > topScore) {\n        topScore = score;\n        topResult = key;\n      }\n    }\n  });\n} catch (e) {\n  // Use default on parse error\n}\n\nif (!topResult) {\n  topResult = defaults[projectionType];\n  topScore = 50;\n}\n\n// Build projection data based on type\nlet projectionData;\nif (projectionType === 'activity') {\n  projectionData = {\n    timestamp: new Date().toISOString(),\n    category: topResult,\n    description: ctx.event.clean_text,\n    message_url: ctx.event.message_url,\n    confidence: topScore / 100,\n    all_scores: scores\n  };\n} else if (projectionType === 'note') {\n  projectionData = {\n    timestamp: new Date().toISOString(),\n    category: topResult,\n    text: ctx.event.clean_text,\n    message_url: ctx.event.message_url,\n    confidence: topScore / 100,\n    all_scores: scores\n  };\n} else if (projectionType === 'todo') {\n  projectionData = {\n    timestamp: new Date().toISOString(),\n    priority: topResult,\n    description: ctx.event.clean_text,\n    message_url: ctx.event.message_url,\n    confidence: topScore / 100,\n    all_scores: scores,\n    status: 'pending'\n  };\n}\n\nreturn [{\n  json: {\n    ctx: {\n      ...ctx,\n      llm: {\n        result: topResult,\n        confidence: topScore / 100,\n        all_scores: scores,\n        completion_text: llmText,\n        duration_ms: durationMs\n      },\n      db_queries: [{\n        key: 'projection',\n        sql: `WITH new_trace AS (\n  INSERT INTO traces (event_id, step_name, data, trace_chain)\n  VALUES (\n    $1::uuid,\n    $2 || '_classification',\n    jsonb_build_object(\n      'input', jsonb_build_object('text', $3),\n      'completion', $4,\n      'result', jsonb_build_object(\n        'value', $5,\n        'confidence', $6::numeric,\n        'all_scores', $7::jsonb\n      ),\n      'model', 'xiaomi/mimo-v2-flash:free',\n      'duration_ms', $8::integer\n    ),\n    $9::uuid[]\n  )\n  RETURNING id, event_id\n),\nnew_projection AS (\n  INSERT INTO projections (\n    trace_id,\n    event_id,\n    trace_chain,\n    projection_type,\n    data,\n    status,\n    timezone,\n    supersedes_projection_id\n  )\n  SELECT\n    new_trace.id,\n    new_trace.event_id,\n    $9::uuid[] || new_trace.id,\n    $2,\n    $10::jsonb,\n    'auto_confirmed',\n    $11,\n    CASE WHEN $12::uuid[] IS NOT NULL AND array_length($12::uuid[], 1) > 0 THEN ($12::uuid[])[1] ELSE NULL END\n  FROM new_trace\n  RETURNING *\n),\nupdate_voided AS (\n  UPDATE projections\n  SET superseded_by_projection_id = (SELECT id FROM new_projection)\n  WHERE id = ANY($12::uuid[])\n  RETURNING id\n)\nSELECT np.*, COALESCE((SELECT array_agg(id) FROM update_voided), ARRAY[]::uuid[]) as linked_voided_ids\nFROM new_projection np;`,\n        params: [\n          ctx.event.event_id,\n          projectionType,\n          ctx.event.clean_text,\n          llmText,\n          topResult,\n          topScore / 100,\n          JSON.stringify(scores),\n          durationMs,\n          traceChainPg,\n          JSON.stringify(projectionData),\n          ctx.event.timezone,\n          voidedProjectionIdsPg\n        ]\n      }]\n    },\n    projection_type: projectionType,\n    projection_data: projectionData\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -352,
        704
      ],
      "id": "parse-classification",
      "name": "Parse Classification"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "PLACEHOLDER_WILL_BE_FIXED_BY_DEPLOY",
          "mode": "list",
          "cachedResultName": "Execute_Queries"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {}
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        -128,
        704
      ],
      "id": "store-projection",
      "name": "Store Projection"
    },
    {
      "parameters": {
        "resource": "message",
        "guildId": {
          "__rl": true,
          "value": "={{ $('Parse Classification').item.json.ctx.event.guild_id }}",
          "mode": "id"
        },
        "channelId": {
          "__rl": true,
          "value": "={{ $env.DISCORD_CHANNEL_KAIRON_LOGS }}",
          "mode": "id"
        },
        "content": "=**[{{ $('Parse Classification').item.json.projection_type.charAt(0).toUpperCase() + $('Parse Classification').item.json.projection_type.slice(1) }} Classification]**\n**Message:** {{ $('Parse Classification').item.json.ctx.event.clean_text }}\n**Result:** {{ $('Parse Classification').item.json.ctx.llm.result }}\n**Confidence:** [ {{ Object.entries($('Parse Classification').item.json.ctx.llm.all_scores || {}).sort((a, b) => b[1] - a[1]).map(([k, v]) => `${k}:${v}%`).join(' | ') }} ]",
        "options": {}
      },
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        96,
        704
      ],
      "id": "log-to-kairon-logs",
      "name": "Log to Kairon Logs",
      "webhookId": "capture-projection-log",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000,
      "credentials": {
        "discordBotApi": {
          "id": "hvetTjtpeKFB1V0I",
          "name": "Discord Bot account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Extract text for embedding from projection data\n// Activity uses 'description', Note/Todo use 'text'\nconst ctx = $json.ctx;\nconst projection = ctx.db?.projection?.row || {};\nconst data = projection.data || {};\nconst embeddingText = data.description || data.text || '';\n\nreturn [{\n  json: {\n    projection_id: projection.id,\n    embedding_text: embeddingText\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        96,
        496
      ],
      "id": "prepare-embedding-text",
      "name": "Prepare Embedding Text"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.EMBEDDING_SERVICE_URL }}/embed",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"texts\": [{{ JSON.stringify($json.embedding_text || '') }}]\n}",
        "options": {
          "timeout": 10000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        320,
        496
      ],
      "id": "embed-projection-text",
      "name": "Embed Projection Text",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Build embedding insert query for Execute_Queries\nconst prepareData = $('Prepare Embedding Text').first().json;\nconst embeddings = $json.embeddings;\n\n// Check if we have a valid embedding\nif (!embeddings || !embeddings[0]) {\n  return [];  // Skip if no embedding\n}\n\nconst embeddingVector = '[' + embeddings[0].join(',') + ']';\n\nreturn [{\n  json: {\n    ctx: {\n      db_queries: [{\n        key: 'embedding',\n        sql: `-- Insert embedding for the projection (fire-and-forget)\nINSERT INTO embeddings (projection_id, model, embedding_data, embedded_text, embedding)\nSELECT \n  $1::uuid,\n  'all-MiniLM-L6-v2',\n  '{}',\n  $2,\n  $3::vector\nWHERE $3 IS NOT NULL\nON CONFLICT DO NOTHING;`,\n        params: [\n          prepareData.projection_id,\n          prepareData.embedding_text,\n          embeddingVector\n        ]\n      }]\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        496
      ],
      "id": "build-embedding-query",
      "name": "Build Embedding Query"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "PLACEHOLDER_WILL_BE_FIXED_BY_DEPLOY",
          "mode": "list",
          "cachedResultName": "Execute_Queries"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {}
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        768,
        496
      ],
      "id": "insert-embedding",
      "name": "Insert Embedding",
      "continueOnFail": true
    }
  ],
  "connections": {
    "Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Prepare Routing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Routing": {
      "main": [
        [
          {
            "node": "Route by Type",
            "type": "main",
            "index": 0
          },
          {
            "node": "Add Type Reaction",
            "type": "main",
            "index": 0
          },
          {
            "node": "Remove \ud83d\udd35 Reaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Type": {
      "main": [
        [
          {
            "node": "Activity Classifier",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Note Classifier",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Todo Classifier",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Note Classifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Activity Classifier": {
      "main": [
        [
          {
            "node": "Merge Classifiers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Note Classifier": {
      "main": [
        [
          {
            "node": "Merge Classifiers",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Todo Classifier": {
      "main": [
        [
          {
            "node": "Merge Classifiers",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Merge Classifiers": {
      "main": [
        [
          {
            "node": "Parse Classification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Classification": {
      "main": [
        [
          {
            "node": "Store Projection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Projection": {
      "main": [
        [
          {
            "node": "Log to Kairon Logs",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Embedding Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Embedding Text": {
      "main": [
        [
          {
            "node": "Embed Projection Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embed Projection Text": {
      "main": [
        [
          {
            "node": "Build Embedding Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Embedding Query": {
      "main": [
        [
          {
            "node": "Insert Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "mimo-v2-flash": {
      "ai_languageModel": [
        [
          {
            "node": "Activity Classifier",
            "type": "ai_languageModel",
            "index": 0
          }
        ],
        [
          {
            "node": "Note Classifier",
            "type": "ai_languageModel",
            "index": 0
          }
        ],
        [
          {
            "node": "Todo Classifier",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "nemotron-nano-9b": {
      "ai_languageModel": [
        [
          {
            "node": "Activity Classifier",
            "type": "ai_languageModel",
            "index": 1
          }
        ],
        [
          {
            "node": "Note Classifier",
            "type": "ai_languageModel",
            "index": 1
          }
        ],
        [
          {
            "node": "Todo Classifier",
            "type": "ai_languageModel",
            "index": 1
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "JOXLqn9TTznBdo7Q"
  },
  "staticData": null,
  "meta": null,
  "active": false
}