{
  "name": "Generate_Nudge",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        0,
        0
      ],
      "id": "workflow-trigger",
      "name": "When Called by Another Workflow"
    },
    {
      "parameters": {
        "jsCode": "// Extract trigger_reason from caller, default to 'cron'\n// Prepare event data and db_writes for Write_DB\nconst input = $json;\nconst triggerReason = input.trigger_reason || 'cron';\nconst now = new Date();\nconst idempotencyKey = `scheduled:nudge:${now.toISOString().slice(0, 16)}:${triggerReason}`;\n\nreturn [{\n  json: {\n    ctx: {\n      event_prep: {\n        idempotency_key: idempotencyKey,\n        trigger_reason: triggerReason,\n        timestamp: now.toISOString()\n      }\n    },\n    db_writes: [{\n      key: 'event',\n      sql: `INSERT INTO events (idempotency_key, event_type, payload, timezone) VALUES ($1, 'system', jsonb_build_object('trigger_type', 'nudge', 'trigger_reason', $2), COALESCE((SELECT value FROM config WHERE key = 'timezone'), 'UTC')) ON CONFLICT (event_type, idempotency_key) DO UPDATE SET id = events.id, timezone = EXCLUDED.timezone RETURNING id, timezone`,\n      params: [idempotencyKey, triggerReason]\n    }]\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        224,
        0
      ],
      "id": "prepare-event",
      "name": "Prepare Event"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "zgJX3AbUNUvDJa48"
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        448,
        0
      ],
      "id": "insert-event",
      "name": "Insert Event Write_DB"
    },
    {
      "parameters": {
        "jsCode": "// Initialize ctx with event_id and prepare batch queries\n// Write_DB returns result in ctx.db.event.row\nconst ctx = $json.ctx;\nconst eventResult = ctx.db?.event?.row || {};\nconst prepareData = ctx.event_prep || {};\n\nreturn [{\n  json: {\n    ctx: {\n      event: {\n        event_id: eventResult.id,\n        trigger_type: 'nudge',\n        trigger_reason: prepareData.trigger_reason,\n        timestamp: prepareData.timestamp,\n        timezone: eventResult.timezone || 'UTC',\n        trace_chain: [eventResult.id]\n      },\n      db_queries: [\n        {\n          key: 'north_star',\n          sql: \"SELECT value FROM config WHERE key = 'north_star'\"\n        },\n        {\n          key: 'activities',\n          sql: \"SELECT (p.data->>'timestamp')::timestamptz as timestamp, p.data->>'category' as category, p.data->>'description' as description FROM projections p WHERE p.projection_type = 'activity' AND p.status IN ('auto_confirmed', 'confirmed') AND (p.data->>'timestamp')::timestamptz >= NOW() - INTERVAL '4 hours' ORDER BY (p.data->>'timestamp')::timestamptz DESC\"\n        },\n        {\n          key: 'last_note',\n          sql: \"SELECT (p.data->>'timestamp')::timestamptz as timestamp, p.data->>'category' as category, p.data->>'text' as text FROM projections p WHERE p.projection_type = 'note' AND p.status IN ('auto_confirmed', 'confirmed') ORDER BY (p.data->>'timestamp')::timestamptz DESC LIMIT 1\"\n        },\n        {\n          key: 'timezone',\n          sql: \"SELECT value as timezone FROM config WHERE key = 'timezone'\"\n        }\n      ]\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        0
      ],
      "id": "init-ctx",
      "name": "Initialize ctx + Prepare Queries"
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": {
          "__rl": true,
          "mode": "list",
          "value": "UpiUvzlgVuMdYsnp"
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        896,
        0
      ],
      "id": "query-db",
      "name": "Query DB"
    },
    {
      "parameters": {
        "jsCode": "// Build LLM prompt context from Query_DB results\nconst ctx = $json.ctx;\n\n// Extract timezone (default to event timezone or UTC)\nconst timezone = ctx.db?.timezone?.results[0]?.timezone || ctx.event.timezone || 'UTC';\n\n// Helper to format time in user's timezone\nconst formatTime = (isoString) => {\n  try {\n    return new Date(isoString).toLocaleTimeString('en-US', { \n      timeZone: timezone, \n      hour: 'numeric', \n      minute: '2-digit' \n    });\n  } catch (e) {\n    return new Date(isoString).toLocaleTimeString('en-US', { \n      hour: 'numeric', \n      minute: '2-digit' \n    });\n  }\n};\n\n// Extract north star (fallback to introspection prompt)\nconst northStar = ctx.db?.north_star?.results[0]?.value || 'To determine my north star from deep introspection';\n\n// Extract activities from db results\nconst activityItems = ctx.db?.activities?.results || [];\n\n// Extract last note from db results  \nconst noteItems = ctx.db?.last_note?.results || [];\n\n// Format activities list with user's timezone\nlet activitiesList = '';\nlet noActivities = true;\nif (activityItems.length === 0) {\n  activitiesList = '(No logged activity)';\n} else {\n  noActivities = false;\n  activityItems.forEach(item => {\n    const time = formatTime(item.timestamp);\n    activitiesList += `- ${time} [${item.category}] ${item.description}\\n`;\n  });\n}\n\n// Format last note with user's timezone\nlet lastNote = '(None)';\nif (noteItems.length > 0 && noteItems[0].text) {\n  const note = noteItems[0];\n  const time = formatTime(note.timestamp);\n  lastNote = `${time} [${note.category}] ${note.text}`;\n}\n\n// Current time in user's timezone for prompt\nlet currentTime;\ntry {\n  currentTime = new Date().toLocaleString('en-US', {\n    timeZone: timezone,\n    weekday: 'short',\n    hour: 'numeric',\n    minute: '2-digit'\n  });\n} catch (e) {\n  currentTime = new Date().toLocaleString('en-US', {\n    weekday: 'short',\n    hour: 'numeric',\n    minute: '2-digit'\n  });\n}\n\nreturn [{\n  json: {\n    ctx,\n    north_star: northStar,\n    recent_activities: activitiesList,\n    no_activities: noActivities,\n    last_note: lastNote,\n    timestamp: currentTime,\n    activity_count: activityItems.length,\n    inference_start: Date.now()\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        0
      ],
      "id": "prepare-prompt-data",
      "name": "Prepare Prompt Data"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a life coach checking in on your client. Current time: {{ $json.timestamp }}\n\n## Context (for your understanding only - do not mention directly)\nClient's guiding principle: {{ $json.north_star }}\n\n## Recent Activity (last 4 hours)\n{{ $json.recent_activities }}\n\n## Last Note\n{{ $json.last_note }}\n\n## Your Task\nDecide whether to nudge the client right now. You have three options:\n\n**SKIP** - Say nothing. Use when:\n- They're clearly in deep work (recent focused activity)\n- It's late night/early morning (let them sleep)\n- Recent activity shows good momentum\n- A nudge would interrupt more than help\n\n**ENCOURAGE** - Affirm what they're doing. Use when:\n- They're making good progress\n- They're on a good streak\n- They might need a small boost to keep going\n\n**REDIRECT** - Gently suggest a shift. Use when:\n- They've been on one thing too long (3+ hours)\n- Time of day suggests a transition (morning focus -> lunch break)\n- They seem stuck or scattered\n- A break or change would serve them\n\n## Output Format\nFirst line: SKIP, ENCOURAGE, or REDIRECT\nIf not SKIP, second line onward: Your message (1-2 sentences, warm but concise)\n\n## Important\n- Never mention \"north star\", \"guiding principle\", or similar phrases\n- Focus on the concrete activity and practical observations\n- Be natural and conversational\n\n## Examples\n\nSKIP\n\n---\n\nENCOURAGE\nNice flow on the router work - keep going.\n\n---\n\nREDIRECT\nYou've been heads-down for 3 hours. Quick stretch or refill water before the next push?\n\n---\n\nSKIP\n\n---\n\nENCOURAGE\nMorning deep work paying off. This is the kind of focus that compounds.\n\n---\n\nREDIRECT\nIt's 11pm and you're still coding. Tomorrow-you will thank tonight-you for sleeping.",
        "needsFallback": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        1568,
        0
      ],
      "id": "generate-nudge-llm",
      "name": "Generate Nudge with LLM"
    },
    {
      "parameters": {
        "model": "nvidia/nemotron-nano-9b-v2:free",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        1576,
        224
      ],
      "id": "nemotron-nano-9b",
      "name": "nemotron-nano-9b",
      "credentials": {
        "openRouterApi": {
          "id": "r79IBN16aZtPIN8T",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "model": "xiaomi/mimo-v2-flash:free",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        1704,
        224
      ],
      "id": "mimo-v2-flash",
      "name": "mimo-v2-flash",
      "credentials": {
        "openRouterApi": {
          "id": "r79IBN16aZtPIN8T",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM response - determine SKIP/ENCOURAGE/REDIRECT\n// Also prepare db_writes for Store Trace Write_DB\nconst prepareData = $('Prepare Prompt Data').first().json;\nconst llmText = $json.text?.trim() || '';\nconst durationMs = Date.now() - prepareData.inference_start;\nconst ctx = prepareData.ctx;\n\n// Parse the decision from first line\nconst lines = llmText.split('\\n').filter(l => l.trim());\nconst decision = (lines[0] || '').trim().toUpperCase();\n\n// Extract message (everything after first line)\nconst message = lines.slice(1).join('\\n').trim();\n\n// Determine if we should skip\nconst shouldSkip = decision === 'SKIP' || !['ENCOURAGE', 'REDIRECT'].includes(decision);\n\n// Format trace_chain for PostgreSQL (with null safety)\nconst traceChain = ctx?.event?.trace_chain || [];\nconst traceChainPg = '{' + traceChain.join(',') + '}';\n\n// Prepare LLM input for trace data\nconst llmInput = {\n  north_star: prepareData.north_star,\n  recent_activities: prepareData.recent_activities,\n  last_note: prepareData.last_note,\n  timestamp: prepareData.timestamp,\n  activity_count: prepareData.activity_count\n};\n\n// Prepare trace data JSON\nconst traceData = JSON.stringify({\n  input: llmInput,\n  prompt: 'nudge-prompt',\n  completion: llmText,\n  result: {\n    decision: decision,\n    message: message,\n    should_skip: shouldSkip\n  },\n  duration_ms: durationMs\n});\n\nreturn [{\n  json: {\n    ctx: {\n      ...ctx,\n      llm: {\n        decision: decision,\n        message: message,\n        should_skip: shouldSkip,\n        duration_ms: durationMs,\n        response: llmText,\n        input: llmInput\n      }\n    },\n    db_writes: [{\n      key: 'trace',\n      sql: `INSERT INTO traces (event_id, step_name, data, trace_chain)\n            VALUES ($1::uuid, 'nudge', $2::jsonb, $3::uuid[])\n            RETURNING id, trace_chain || id AS updated_trace_chain`,\n      params: [ctx.event.event_id, traceData, traceChainPg]\n    }]\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        0
      ],
      "id": "parse-llm-response",
      "name": "Parse LLM Response"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "zgJX3AbUNUvDJa48"
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        2016,
        0
      ],
      "id": "store-trace",
      "name": "Store Trace Write_DB"
    },
    {
      "parameters": {
        "jsCode": "// Merge trace result from Write_DB and prepare projection write\nconst ctx = $json.ctx;\nconst traceResult = ctx.db?.trace?.row || {};\n\nconst updatedTraceChain = traceResult.updated_trace_chain || [];\nconst updatedTraceChainPg = '{' + updatedTraceChain.join(',') + '}';\n\n// Pre-stringify projection data for Postgres\nconst projectionData = JSON.stringify({\n  timestamp: new Date().toISOString(),\n  decision: ctx.llm.decision,\n  text: ctx.llm.message\n});\n\nreturn [{\n  json: {\n    ctx: {\n      ...ctx,\n      trace: {\n        trace_id: traceResult.id,\n        trace_chain: updatedTraceChain,\n        trace_chain_pg: updatedTraceChainPg\n      }\n    },\n    db_writes: [{\n      key: 'projection',\n      sql: `INSERT INTO projections (trace_id, event_id, trace_chain, projection_type, data, status, timezone)\n            VALUES ($1::uuid, $2::uuid, $3::uuid[], 'nudge', $4::jsonb, 'auto_confirmed', $5)\n            RETURNING id`,\n      params: [traceResult.id, ctx.event.event_id, updatedTraceChainPg, projectionData, ctx.event.timezone]\n    }]\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        0
      ],
      "id": "merge-trace-result",
      "name": "Merge Trace Result"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "check-skip",
              "leftValue": "={{ $json.ctx.llm.should_skip }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        2464,
        0
      ],
      "id": "if-should-skip",
      "name": "If Should Skip"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "zgJX3AbUNUvDJa48"
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        2688,
        80
      ],
      "id": "store-projection",
      "name": "Store Projection Write_DB"
    },
    {
      "parameters": {
        "jsCode": "// Merge projection result from Write_DB for Discord\nconst ctx = $json.ctx;\nconst projResult = ctx.db?.projection?.row || {};\n\nreturn [{\n  json: {\n    ctx: {\n      ...ctx,\n      projection: {\n        projection_id: projResult.id\n      }\n    },\n    // Pass message for Discord node\n    message: ctx.llm.message,\n    decision: ctx.llm.decision\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2912,
        80
      ],
      "id": "merge-for-discord",
      "name": "Merge for Discord"
    },
    {
      "parameters": {
        "resource": "message",
        "guildId": {
          "__rl": true,
          "value": "={{ $env.DISCORD_GUILD_ID }}",
          "mode": "id"
        },
        "channelId": {
          "__rl": true,
          "value": "={{ $env.DISCORD_CHANNEL_ARCANE_SHELL }}",
          "mode": "id"
        },
        "content": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        3136,
        80
      ],
      "id": "send-nudge",
      "name": "Send Nudge",
      "credentials": {
        "discordBotApi": {
          "id": "hvetTjtpeKFB1V0I",
          "name": "Discord Bot account"
        }
      },
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "jsCode": "// Prepare db_writes for Update Projection with Message ID\nconst discordResult = $json;\nconst ctx = $('Merge for Discord').first().json.ctx;\n\n// Get env vars - these need to be passed via the execution context\n// Since Write_DB uses Code nodes internally, we pass the channel/guild from ctx\nconst channelId = $env.DISCORD_CHANNEL_ARCANE_SHELL;\nconst guildId = $env.DISCORD_GUILD_ID;\n\nreturn [{\n  json: {\n    ctx,\n    db_writes: [{\n      key: 'update_projection',\n      sql: `UPDATE projections \n            SET data = data || jsonb_build_object(\n              'discord_message_id', $1,\n              'discord_channel_id', $2,\n              'discord_guild_id', $3\n            )\n            WHERE id = $4::uuid\n            RETURNING id`,\n      params: [discordResult.id, channelId, guildId, ctx.projection.projection_id]\n    }]\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3360,
        80
      ],
      "id": "prepare-update",
      "name": "Prepare Update"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "mode": "id",
          "value": "zgJX3AbUNUvDJa48"
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        3584,
        80
      ],
      "id": "update-projection-message-id",
      "name": "Update Projection Write_DB"
    }
  ],
  "connections": {
    "When Called by Another Workflow": {
      "main": [
        [
          {
            "node": "Prepare Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Event": {
      "main": [
        [
          {
            "node": "Insert Event Write_DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Event Write_DB": {
      "main": [
        [
          {
            "node": "Initialize ctx + Prepare Queries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize ctx + Prepare Queries": {
      "main": [
        [
          {
            "node": "Query DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Prompt Data": {
      "main": [
        [
          {
            "node": "Generate Nudge with LLM",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Nudge with LLM": {
      "main": [
        [
          {
            "node": "Parse LLM Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse LLM Response": {
      "main": [
        [
          {
            "node": "Store Trace Write_DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Trace Write_DB": {
      "main": [
        [
          {
            "node": "Merge Trace Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Trace Result": {
      "main": [
        [
          {
            "node": "If Should Skip",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Should Skip": {
      "main": [
        [],
        [
          {
            "node": "Store Projection Write_DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Projection Write_DB": {
      "main": [
        [
          {
            "node": "Merge for Discord",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge for Discord": {
      "main": [
        [
          {
            "node": "Send Nudge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Nudge": {
      "main": [
        [
          {
            "node": "Prepare Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Update": {
      "main": [
        [
          {
            "node": "Update Projection Write_DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "nemotron-nano-9b": {
      "ai_languageModel": [
        [
          {
            "node": "Generate Nudge with LLM",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "mimo-v2-flash": {
      "ai_languageModel": [
        [
          {
            "node": "Generate Nudge with LLM",
            "type": "ai_languageModel",
            "index": 1
          }
        ]
      ]
    },
    "Query DB": {
      "main": [
        [
          {
            "node": "Prepare Prompt Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "JOXLqn9TTznBdo7Q",
    "availableInMCP": false
  },
  "staticData": {
    "node:Every 15 Minutes": {
      "recurrenceRules": []
    }
  },
  "meta": null,
  "active": false
}