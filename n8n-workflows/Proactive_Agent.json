{
  "name": "Proactive_Agent",
  "nodes": [
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "={{ $env.WORKFLOW_ID_EXECUTE_QUERIES }}",
          "mode": "id"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        0,
        0
      ],
      "id": "workflow-trigger",
      "name": "WhenCalledByAnotherWorkflow"
    },
    {
      "parameters": {
        "jsCode": "// Extract trigger_reason from caller, default to 'cron'\nconst input = $json;\nconst triggerReason = input.trigger_reason || 'cron';\nconst now = new Date();\nconst idempotencyKey = `scheduled:proactive:${now.toISOString().slice(0, 16)}:${triggerReason}`;\n\nreturn {\n  json: {\n    idempotency_key: idempotencyKey,\n    trigger_reason: triggerReason,\n    timestamp: now.toISOString()\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        224,
        0
      ],
      "id": "prepare-event",
      "name": "PrepareEvent"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Insert system event for proactive agent\nINSERT INTO events (idempotency_key, event_type, payload, timezone)\nVALUES (\n  $1,\n  'system',\n  jsonb_build_object(\n    'trigger_type', 'proactive_agent',\n    'trigger_reason', $2\n  ),\n  COALESCE((SELECT value FROM config WHERE key = 'timezone'), 'UTC')\n)\nON CONFLICT (event_type, idempotency_key) DO UPDATE SET id = events.id, timezone = EXCLUDED.timezone\nRETURNING id, timezone;",
        "options": {
          "values": "{{ $json.idempotency_key }},{{ $json.trigger_reason }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        448,
        0
      ],
      "id": "insert-event",
      "name": "InsertEvent",
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Initialize ctx with event_id\nconst eventResult = $json;\nconst prepareData = $('PrepareEvent').first().json;\n\nreturn {\n  json: {\n    ctx: {\n      event: {\n        event_id: eventResult.id,\n        trigger_type: 'proactive_agent',\n        trigger_reason: prepareData.trigger_reason,\n        timestamp: prepareData.timestamp,\n        timezone: eventResult.timezone || 'UTC',\n        trace_chain: [eventResult.id],\n        trace_chain_pg: `{${eventResult.id}}`\n      },\n      db_queries: [{\n        key: 'history',\n        sql: `\n          (SELECT 'user' as role, payload->>'clean_text' as content, received_at as timestamp\n           FROM events \n           WHERE event_type = 'discord_message'\n           ORDER BY received_at DESC LIMIT 5)\n          UNION ALL\n          (SELECT 'assistant' as role, data->>'message' as content, created_at as timestamp\n           FROM projections\n           WHERE projection_type IN ('nudge', 'pulse')\n           ORDER BY created_at DESC LIMIT 5)\n          ORDER BY timestamp DESC\n          LIMIT 5;\n        `,\n        params: []\n      }]\n    }\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        0
      ],
      "id": "init-ctx",
      "name": "InitializeCtx"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Get active prompt modules, ordered by priority\nSELECT id, name, content, module_type, tags, priority\nFROM prompt_modules\nWHERE active = true\nORDER BY priority ASC;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        896,
        -288
      ],
      "id": "get-prompt-modules",
      "name": "FetchHistory",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT value FROM config WHERE key = 'north_star';",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        896,
        -96
      ],
      "id": "get-north-star",
      "name": "GetNorthStar",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  (p.data->>'timestamp')::timestamptz as timestamp,\n  p.data->>'category' as category,\n  p.data->>'description' as description\nFROM projections p\nWHERE p.projection_type = 'activity'\n  AND p.status IN ('auto_confirmed', 'confirmed')\n  AND (p.data->>'timestamp')::timestamptz >= NOW() - INTERVAL '24 hours'\nORDER BY (p.data->>'timestamp')::timestamptz DESC\nLIMIT 20;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        896,
        96
      ],
      "id": "get-recent-activities",
      "name": "GetRecentActivities(24h)",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  (p.data->>'timestamp')::timestamptz as timestamp,\n  p.data->>'category' as category,\n  p.data->>'text' as text\nFROM projections p\nWHERE p.projection_type = 'note'\n  AND p.status IN ('auto_confirmed', 'confirmed')\n  AND (p.data->>'timestamp')::timestamptz >= NOW() - INTERVAL '7 days'\nORDER BY (p.data->>'timestamp')::timestamptz DESC\nLIMIT 5;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        896,
        288
      ],
      "id": "get-recent-notes",
      "name": "GetRecentNotes(7d)",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  p.id,\n  p.data->>'text' as text,\n  p.data->>'status' as status,\n  p.created_at,\n  EXTRACT(DAY FROM NOW() - p.created_at) as days_pending\nFROM projections p\nWHERE p.projection_type = 'todo'\n  AND p.status IN ('auto_confirmed', 'confirmed')\n  AND COALESCE(p.data->>'status', 'pending') = 'pending'\nORDER BY p.created_at ASC\nLIMIT 10;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        896,
        480
      ],
      "id": "get-pending-todos",
      "name": "GetPendingTodos",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "mode": "append",
        "numberInputs": 6
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        1120,
        0
      ],
      "id": "merge-query-results",
      "name": "MergeQueryResults"
    },
    {
      "parameters": {
        "jsCode": "// Build context summary for semantic module selection\nconst allItems = $input.all();\n\n// Extract ctx\nlet ctx = null;\nfor (const item of allItems) {\n  if (item.json.ctx) {\n    ctx = item.json.ctx;\n    break;\n  }\n}\n\nif (!ctx) {\n  throw new Error('ctx not found in merged items');\n}\n\n// Extract activities, notes, todos\nconst activities = allItems.filter(item => \n  item.json.description !== undefined && !item.json.error\n);\nconst notes = allItems.filter(item => \n  item.json.text !== undefined && \n  item.json.description === undefined &&\n  item.json.days_pending === undefined &&\n  !item.json.error\n);\nconst todos = allItems.filter(item => \n  item.json.days_pending !== undefined && !item.json.error\n);\n\n// Extract technique modules for semantic selection\nconst techniques = allItems.filter(item => \n  item.json.module_type === 'technique'\n).map(item => item.json.content);\n\n// Check for stuck todos (pending > 3 days)\nconst stuckTodos = todos.filter(t => t.json.days_pending > 3);\n\n// Build a context summary for semantic search\nconst summaryParts = [];\n\nif (activities.length > 0) {\n  const recentActivities = activities.slice(0, 3).map(a => a.json.description).join(', ');\n  summaryParts.push(`Recent activities: ${recentActivities}`);\n}\n\nif (notes.length > 0) {\n  const recentNotes = notes.slice(0, 2).map(n => n.json.text.substring(0, 100)).join('; ');\n  summaryParts.push(`Notes: ${recentNotes}`);\n}\n\nif (stuckTodos.length > 0) {\n  summaryParts.push(`Stuck todos: ${stuckTodos.map(t => t.json.text).join(', ')}`);\n} else if (todos.length > 0) {\n  summaryParts.push(`Pending todos: ${todos.slice(0, 3).map(t => t.json.text).join(', ')}`);\n}\n\nif (summaryParts.length === 0) {\n  summaryParts.push('No recent activity logged. User may need a gentle check-in.');\n}\n\nconst contextSummary = summaryParts.join('. ');\n\n// Pass through all items plus the context summary\nreturn [{\n  json: {\n    ctx,\n    context_summary: contextSummary,\n    technique_candidates: techniques,\n    has_stuck_todos: stuckTodos.length > 0,\n    has_activities: activities.length > 0,\n    has_notes: notes.length > 0,\n    all_items: allItems.map(i => i.json)\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1344,
        0
      ],
      "id": "build-context-summary",
      "name": "BuildContextSummary"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.EMBEDDING_SERVICE_URL }}/search",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"query\": {{ JSON.stringify($json.context_summary) }},\n  \"table\": \"prompt_modules\",\n  \"filter\": {\"module_type\": \"technique\"},\n  \"top_k\": 1\n}",
        "options": {
          "timeout": 10000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1568,
        0
      ],
      "id": "semantic-select-techniques",
      "name": "SemanticSelectTechniques",
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.EMBEDDING_SERVICE_URL }}/embed",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"texts\": [{{ JSON.stringify($json.context_summary) }}]\n}",
        "options": {
          "timeout": 10000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1568,
        192
      ],
      "id": "embed-context-for-rag",
      "name": "EmbedContextForRag",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Prepare embedding for pgvector query\nconst contextData = $('BuildContextSummary').first().json;\nconst embedResult = $json;\n\n// Extract the embedding vector\nlet embedding = null;\nif (embedResult.embeddings && embedResult.embeddings.length > 0) {\n  embedding = embedResult.embeddings[0];\n}\n\n// Format as pgvector array string\nlet embeddingPg = null;\nif (embedding) {\n  embeddingPg = '[' + embedding.join(',') + ']';\n}\n\nreturn {\n  json: {\n    ctx: contextData.ctx,\n    context_summary: contextData.context_summary,\n    all_items: contextData.all_items,\n    embedding_pg: embeddingPg,\n    has_embedding: embedding !== null\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        192
      ],
      "id": "prepare-embedding-for-rag",
      "name": "PrepareEmbeddingForRag"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- RAG: Find similar projections using pgvector\nSELECT \n  p.projection_type,\n  COALESCE(p.data->>'description', p.data->>'text') as content,\n  p.data->>'category' as category,\n  (p.data->>'timestamp')::timestamptz as timestamp,\n  e.embedding <=> $1::vector as distance\nFROM embeddings e\nJOIN projections p ON e.projection_id = p.id\nWHERE p.status IN ('auto_confirmed', 'confirmed')\n  AND p.created_at > NOW() - INTERVAL '30 days'\n  AND p.projection_type IN ('activity', 'note')\n  AND e.embedding IS NOT NULL\nORDER BY e.embedding <=> $1::vector\nLIMIT 5;",
        "options": {
          "values": "{{ $json.embedding_pg }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        2016,
        192
      ],
      "id": "rag-similar-projections",
      "name": "RagSimilarProjections",
      "alwaysOutputData": true,
      "continueOnFail": true,
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "mode": "append",
        "numberInputs": 2
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        1792,
        96
      ],
      "id": "merge-semantic-results",
      "name": "MergeSemanticResults"
    },
    {
      "parameters": {
        "jsCode": "// Assemble prompt from modules and context with semantic selection\nconst allItems = $input.all();\n\n// Find the context summary item (has ctx and all_items)\nlet contextData = null;\nfor (const item of allItems) {\n  if (item.json.ctx && item.json.all_items) {\n    contextData = item.json;\n    break;\n  }\n}\n\nif (!contextData) {\n  throw new Error('Context data not found in merged items');\n}\n\nconst ctx = contextData.ctx;\nconst originalItems = contextData.all_items;\nconst timezone = ctx.event.timezone || 'UTC';\n\n// Extract semantic selection results\nlet semanticMatches = [];\nfor (const item of allItems) {\n  if (item.json.results) {\n    semanticMatches = item.json.results;\n    break;\n  }\n}\n\n// Extract conversational history\nlet history = [];\nfor (const item of allItems) {\n  if (item.json.ctx && item.json.ctx.db && item.json.ctx.db.history) {\n    history = item.json.ctx.db.history.rows || [];\n    break;\n  }\n}\n\n// Extract RAG results (similar projections)\nlet ragResults = [];\nfor (const item of allItems) {\n  if (item.json.projection_type !== undefined && item.json.distance !== undefined) {\n    ragResults.push(item.json);\n  }\n}\n\n// Helper to format time in user's timezone\nconst formatTime = (isoString) => {\n  try {\n    return new Date(isoString).toLocaleTimeString('en-US', { \n      timeZone: timezone, \n      hour: 'numeric', \n      minute: '2-digit' \n    });\n  } catch (e) {\n    return new Date(isoString).toLocaleTimeString('en-US', { \n      hour: 'numeric', \n      minute: '2-digit' \n    });\n  }\n};\n\nconst formatDate = (isoString) => {\n  try {\n    return new Date(isoString).toLocaleDateString('en-US', { \n      timeZone: timezone, \n      weekday: 'short',\n      month: 'short', \n      day: 'numeric' \n    });\n  } catch (e) {\n    return new Date(isoString).toLocaleDateString('en-US', { \n      weekday: 'short',\n      month: 'short', \n      day: 'numeric' \n    });\n  }\n};\n\n// Get current hour in user's timezone\nconst now = new Date();\nlet currentHour;\ntry {\n  currentHour = parseInt(now.toLocaleTimeString('en-US', { \n    timeZone: timezone, \n    hour: 'numeric', \n    hour12: false \n  }));\n} catch (e) {\n  currentHour = now.getHours();\n}\n\n// Determine time of day for fallback technique selection\nconst isMorning = currentHour >= 6 && currentHour <= 9;\nconst isEvening = currentHour >= 20 && currentHour <= 23;\n\n// Extract prompt modules from original items\nconst modules = originalItems.filter(item => \n  item.module_type !== undefined\n);\n\n// Extract north star\nlet northStar = 'To determine my north star from deep introspection';\nconst northStarItems = originalItems.filter(item => \n  item.value !== undefined && \n  item.module_type === undefined\n);\nif (northStarItems.length > 0 && northStarItems[0].value) {\n  northStar = northStarItems[0].value;\n}\n\n// Extract activities\nconst activityItems = originalItems.filter(item => \n  item.description !== undefined && \n  !item.error\n);\n\n// Extract notes\nconst noteItems = originalItems.filter(item => \n  item.text !== undefined && \n  item.description === undefined &&\n  item.days_pending === undefined &&\n  !item.error\n);\n\n// Extract todos\nconst todoItems = originalItems.filter(item => \n  item.days_pending !== undefined && \n  !item.error\n);\n\n// Check for stuck todos (pending > 3 days)\nconst stuckTodos = todoItems.filter(t => t.days_pending > 3);\nconst hasStuckTodos = stuckTodos.length > 0;\n\n// Assemble prompt from modules\nconst promptParts = [];\n\n// 1. Always include persona modules (priority 0-10)\nconst personaModules = modules.filter(m => m.module_type === 'persona');\npersonaModules.forEach(m => promptParts.push(m.content));\n\n// 2. Select technique - prefer semantic matches, fall back to time/context based\nlet selectedTechniques = [];\nlet techniqueSource = 'none';\n\nif (semanticMatches.length > 0 && semanticMatches[0].score > 0.3) {\n  // Use semantically selected techniques (top 2 with score > 0.3)\n  selectedTechniques = semanticMatches\n    .filter(m => m.score > 0.3)\n    .slice(0, 2)\n    .map(m => m.text);\n  techniqueSource = 'semantic';\n} else {\n  // Fallback to time-based selection\n  if (isMorning) {\n    const morningTechnique = modules.find(m => m.name === 'technique_morning');\n    if (morningTechnique) selectedTechniques.push(morningTechnique.content);\n    techniqueSource = 'morning';\n  } else if (isEvening) {\n    const eveningTechnique = modules.find(m => m.name === 'technique_evening');\n    if (eveningTechnique) selectedTechniques.push(eveningTechnique.content);\n    techniqueSource = 'evening';\n  } else if (hasStuckTodos) {\n    const stuckTechnique = modules.find(m => m.name === 'technique_stuck_todo');\n    if (stuckTechnique) selectedTechniques.push(stuckTechnique.content);\n    techniqueSource = 'stuck_todo';\n  }\n}\n\nselectedTechniques.forEach(t => promptParts.push(t));\n\n// 3. Build context section\nlet contextSection = '## Current Context\\n\\n';\ncontextSection += `**Time:** ${formatDate(now.toISOString())} ${formatTime(now.toISOString())}\\n`;\ncontextSection += `**North Star:** ${northStar}\\n\\n`;\n\n// Add conversational history\nif (history.length > 0) {\n  contextSection += '### Recent Conversation\\n';\n  history.reverse().forEach(h => {\n    const role = h.role === 'user' ? 'User' : 'Kairon';\n    contextSection += `**${role}:** ${h.content}\\n`;\n  });\n  contextSection += '\\n';\n}\n\n// Format activities\ncontextSection += '### Recent Activities (last 24h)\\n';\nif (activityItems.length === 0) {\n  contextSection += '(No logged activity)\\n';\n} else {\n  activityItems.slice(0, 10).forEach(item => {\n    const time = formatTime(item.timestamp);\n    contextSection += `- ${time}: ${item.description} [${item.category}]\\n`;\n  });\n}\ncontextSection += '\\n';\n\n// Format notes\ncontextSection += '### Recent Notes\\n';\nif (noteItems.length === 0) {\n  contextSection += '(No recent notes)\\n';\n} else {\n  noteItems.forEach(item => {\n    const date = formatDate(item.timestamp);\n    const preview = item.text.substring(0, 100) + (item.text.length > 100 ? '...' : '');\n    contextSection += `- ${date}: ${preview}\\n`;\n  });\n}\ncontextSection += '\\n';\n\n// Format todos\ncontextSection += '### Pending Todos\\n';\nif (todoItems.length === 0) {\n  contextSection += '(No pending todos)\\n';\n} else {\n  todoItems.forEach(item => {\n    const daysStr = item.days_pending > 0 ? ` (${Math.floor(item.days_pending)} days)` : '';\n    contextSection += `- ${item.text}${daysStr}\\n`;\n  });\n}\n\n// 4. Add RAG context if available (similar past entries)\nif (ragResults.length > 0) {\n  contextSection += '\\n### Related Past Entries (for context)\\n';\n  ragResults.slice(0, 3).forEach(item => {\n    const date = item.timestamp ? formatDate(item.timestamp) : 'Unknown';\n    const content = item.content?.substring(0, 80) || 'No content';\n    contextSection += `- ${date}: ${content}${item.content?.length > 80 ? '...' : ''} [${item.projection_type}]\\n`;\n  });\n}\n\npromptParts.push(contextSection);\n\n// 5. Include format module\nconst formatModule = modules.find(m => m.module_type === 'format');\nif (formatModule) {\n  promptParts.push(formatModule.content);\n}\n\n// 6. Always include guardrail modules (priority 200+)\nconst guardrailModules = modules.filter(m => m.module_type === 'guardrail');\nguardrailModules.forEach(m => promptParts.push(m.content));\n\n// Assemble final prompt\nconst assembledPrompt = promptParts.join('\\n\\n---\\n\\n');\n\n// Determine the context description for the agent\nlet contextDescription = 'general check-in';\nif (isMorning) contextDescription = 'morning check-in';\nelse if (isEvening) contextDescription = 'evening reflection';\nelse if (hasStuckTodos) contextDescription = 'stuck todo nudge';\nelse if (activityItems.length === 0) contextDescription = 'no recent activity';\n\n// Format trace_chain for PostgreSQL\nconst traceChain = ctx.event.trace_chain || [];\nconst traceChainPg = '{' + traceChain.join(',') + '}';\n\nreturn [{\n  json: {\n    ctx,\n    assembled_prompt: assembledPrompt,\n    context_description: contextDescription,\n    technique_source: techniqueSource,\n    techniques_used: selectedTechniques.length,\n    semantic_scores: semanticMatches.map(m => m.score),\n    rag_count: ragResults.length,\n    inference_start: Date.now(),\n    trace_chain_pg: traceChainPg,\n    // Metadata for trace storage\n    input_summary: {\n      activity_count: activityItems.length,\n      note_count: noteItems.length,\n      todo_count: todoItems.length,\n      stuck_todo_count: stuckTodos.length,\n      current_hour: currentHour,\n      is_morning: isMorning,\n      is_evening: isEvening,\n      technique_source: techniqueSource,\n      semantic_match_count: semanticMatches.length,\n      rag_result_count: ragResults.length\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2016,
        96
      ],
      "id": "assemble-prompt",
      "name": "AssemblePrompt"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.assembled_prompt }}\n\n---\n\n## Your Task\n\nBased on the context above, compose a proactive message to the user. This is a {{ $json.context_description }}.\n\nYour message should be helpful, personal, and timely. Reference their specific activities, notes, or todos when relevant.\n\nRespond with ONLY the message you would send to the user. No preamble, no explanation - just the message itself.",
        "needsFallback": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2240,
        96
      ],
      "id": "generate-message-llm",
      "name": "GenerateMessageWithLlm"
    },
    {
      "parameters": {
        "model": "nvidia/nemotron-nano-9b-v2:free",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2248,
        320
      ],
      "id": "nemotron-nano-9b",
      "name": "NemotronNano9b",
      "credentials": {
        "openRouterApi": {
          "id": "nB20cMgvlwePo3oC",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "model": "xiaomi/mimo-v2-flash:free",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        2376,
        320
      ],
      "id": "mimo-v2-flash",
      "name": "MimoV2Flash",
      "credentials": {
        "openRouterApi": {
          "id": "nB20cMgvlwePo3oC",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM response\nconst assembleData = $('AssemblePrompt').first().json;\nconst llmText = $json.text?.trim() || '';\nconst durationMs = Date.now() - assembleData.inference_start;\nconst ctx = assembleData.ctx;\n\nlet message = '';\nlet nextPulseMinutes = 120;\nlet reasoning = '';\n\ntry {\n  // Extract JSON from response (handling potential markdown blocks)\n  const jsonMatch = llmText.match(/\\{[\\s\\S]*\\}/);\n  const data = JSON.parse(jsonMatch ? jsonMatch[0] : llmText);\n  message = data.message || '';\n  nextPulseMinutes = parseInt(data.next_pulse_minutes) || 120;\n  reasoning = data.reasoning || '';\n} catch (e) {\n  // Fallback for non-JSON or malformed responses\n  message = llmText.replace(/^```[a-z]*\\n?/, '').replace(/\\n?```$/, '').trim();\n}\n\n// Check if message is empty or too short\nconst isEmpty = !message || message.length < 10;\n\nreturn {\n  json: {\n    ctx,\n    message: message,\n    next_pulse_minutes: nextPulseMinutes,\n    reasoning: reasoning,\n    is_empty: isEmpty,\n    duration_ms: durationMs,\n    trace_chain_pg: assembleData.trace_chain_pg,\n    llm_response: llmText,\n    assembled_prompt: assembleData.assembled_prompt,\n    context_description: assembleData.context_description,\n    technique_source: assembleData.technique_source,\n    input_summary: assembleData.input_summary\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2464,
        96
      ],
      "id": "parse-llm-response",
      "name": "ParseLlmResponse"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO traces (event_id, step_name, data, trace_chain)\nVALUES (\n  $1::uuid,\n  'proactive_agent',\n  jsonb_build_object(\n    'prompt', $2,\n    'completion', $3,\n    'context_description', $4,\n    'technique_source', $5,\n    'input_summary', $6::jsonb,\n    'duration_ms', $7::integer\n  ),\n  $8::uuid[]\n)\nRETURNING id, trace_chain || id AS updated_trace_chain;",
        "options": {
          "values": "{{ $json.ctx.event.event_id }},{{ $json.assembled_prompt }},{{ $json.llm_response }},{{ $json.context_description }},{{ $json.technique_source }},{{ JSON.stringify($json.input_summary) }},{{ $json.duration_ms }},{{ $json.trace_chain_pg }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        2688,
        96
      ],
      "id": "store-trace",
      "name": "StoreTrace",
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge trace result with parsed LLM data\nconst traceResult = $json;\nconst parseData = $('ParseLlmResponse').first().json;\n\nconst updatedTraceChain = traceResult.updated_trace_chain || [];\nconst updatedTraceChainPg = '{' + updatedTraceChain.join(',') + '}';\n\n// Pre-stringify projection data for Postgres\nconst projectionData = {\n  timestamp: new Date().toISOString(),\n  text: parseData.message,\n  context_description: parseData.context_description,\n  technique_source: parseData.technique_source\n};\n\nreturn {\n  json: {\n    ctx: parseData.ctx,\n    trace_id: traceResult.id,\n    trace_chain_pg: updatedTraceChainPg,\n    message: parseData.message,\n    is_empty: parseData.is_empty,\n    projection_data_json: JSON.stringify(projectionData)\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2912,
        96
      ],
      "id": "merge-trace-result",
      "name": "MergeTraceResult"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "check-empty",
              "leftValue": "={{ $json.is_empty }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        3136,
        96
      ],
      "id": "if-empty",
      "name": "IfEmptyMessage"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO projections (trace_id, event_id, trace_chain, projection_type, data, status, timezone)\nVALUES (\n  $1::uuid,\n  $2::uuid,\n  $3::uuid[],\n  'nudge',\n  $4::jsonb,\n  'auto_confirmed',\n  $5\n)\nRETURNING id;",
        "options": {
          "values": "{{ $json.trace_id }},{{ $json.ctx.event.event_id }},{{ $json.trace_chain_pg }},{{ $json.projection_data_json }},{{ $json.ctx.event.timezone }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        3360,
        176
      ],
      "id": "store-projection",
      "name": "StoreProjection",
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge projection result for Discord\nconst projResult = $json;\nconst mergeData = $('MergeTraceResult').first().json;\n\nreturn {\n  json: {\n    ctx: mergeData.ctx,\n    projection_id: projResult.id,\n    message: mergeData.message\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3584,
        176
      ],
      "id": "merge-for-discord",
      "name": "MergeForDiscord"
    },
    {
      "parameters": {
        "resource": "message",
        "guildId": {
          "__rl": true,
          "value": "={{ $env.DISCORD_GUILD_ID }}",
          "mode": "id"
        },
        "channelId": {
          "__rl": true,
          "value": "={{ $env.DISCORD_CHANNEL_ARCANE_SHELL }}",
          "mode": "id"
        },
        "content": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        3808,
        176
      ],
      "id": "send-message",
      "name": "SendMessage",
      "credentials": {
        "discordBotApi": {
          "id": "HzhURrgtJQZuwPMZ",
          "name": "Discord Bot account"
        }
      },
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Update projection with Discord message ID for void support\nUPDATE projections \nSET data = data || jsonb_build_object(\n  'discord_message_id', $1,\n  'discord_channel_id', $2,\n  'discord_guild_id', $3\n)\nWHERE id = $4::uuid\nRETURNING id;",
        "options": {
          "values": "{{ $json.id }},{{ $env.DISCORD_CHANNEL_ARCANE_SHELL }},{{ $env.DISCORD_GUILD_ID }},{{ $('Merge for Discord').first().json.projection_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        4032,
        176
      ],
      "id": "update-projection-message-id",
      "name": "UpdateProjectionWithMessageId",
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE config \nSET value = (NOW() + ($1 || ' minutes')::interval)::text, updated_at = NOW()\nWHERE key = 'next_pulse';",
        "options": {
          "values": "={{ $json.next_pulse_minutes }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        2688,
        288
      ],
      "id": "update-next-pulse",
      "name": "UpdateNextPulse",
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "resource": "reaction",
        "operation": "add",
        "guildId": {
          "__rl": true,
          "value": "={{ $env.DISCORD_GUILD_ID }}",
          "mode": "id"
        },
        "channelId": {
          "__rl": true,
          "value": "={{ $env.DISCORD_CHANNEL_ARCANE_SHELL }}",
          "mode": "id"
        },
        "messageId": "={{ $json.id }}",
        "emoji": "❓",
        "options": {}
      },
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        4256,
        176
      ],
      "id": "add-diagnostic-reaction",
      "name": "AddDiagnosticReaction",
      "credentials": {
        "discordBotApi": {
          "id": "HzhURrgtJQZuwPMZ",
          "name": "Discord Bot account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT value FROM config WHERE key = 'verbose';",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        4480,
        176
      ],
      "id": "check-verbose-config",
      "name": "CheckVerboseConfig",
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "is-verbose",
              "leftValue": "={{ $json.value }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        4704,
        176
      ],
      "id": "if-verbose",
      "name": "IfVerbose?"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "wVpslhMBnrsgDaOR",
          "mode": "list",
          "cachedResultName": "Show_Projection_Details",
          "cachedResultUrl": "/workflow/wVpslhMBnrsgDaOR"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "ctx": "={{ $('Merge for Discord').first().json.ctx }}",
            "emoji": "❓"
          },
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        4928,
        256
      ],
      "id": "trigger-show-details",
      "name": "TriggerShowDetails"
    }
  ],
  "connections": {
    "WhenCalledByAnotherWorkflow": {
      "main": [
        [
          {
            "node": "PrepareEvent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PrepareEvent": {
      "main": [
        [
          {
            "node": "InsertEvent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "InsertEvent": {
      "main": [
        [
          {
            "node": "InitializeCtx",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "InitializeCtx": {
      "main": [
        [
          {
            "node": "FetchHistory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FetchHistory": {
      "main": [
        [
          {
            "node": "GetNorthStar",
            "type": "main",
            "index": 0
          },
          {
            "node": "GetRecentActivities(24h)",
            "type": "main",
            "index": 0
          },
          {
            "node": "GetRecentNotes(7d)",
            "type": "main",
            "index": 0
          },
          {
            "node": "GetPendingTodos",
            "type": "main",
            "index": 0
          },
          {
            "node": "MergeQueryResults",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GetNorthStar": {
      "main": [
        [
          {
            "node": "MergeQueryResults",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "GetRecentActivities(24h)": {
      "main": [
        [
          {
            "node": "MergeQueryResults",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "GetRecentNotes(7d)": {
      "main": [
        [
          {
            "node": "MergeQueryResults",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "GetPendingTodos": {
      "main": [
        [
          {
            "node": "MergeQueryResults",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "MergeQueryResults": {
      "main": [
        [
          {
            "node": "BuildContextSummary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BuildContextSummary": {
      "main": [
        [
          {
            "node": "SemanticSelectTechniques",
            "type": "main",
            "index": 0
          },
          {
            "node": "EmbedContextForRag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "EmbedContextForRag": {
      "main": [
        [
          {
            "node": "PrepareEmbeddingForRag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PrepareEmbeddingForRag": {
      "main": [
        [
          {
            "node": "RagSimilarProjections",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SemanticSelectTechniques": {
      "main": [
        [
          {
            "node": "MergeSemanticResults",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RagSimilarProjections": {
      "main": [
        [
          {
            "node": "MergeSemanticResults",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "MergeSemanticResults": {
      "main": [
        [
          {
            "node": "AssemblePrompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AssemblePrompt": {
      "main": [
        [
          {
            "node": "GenerateMessageWithLlm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GenerateMessageWithLlm": {
      "main": [
        [
          {
            "node": "ParseLlmResponse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ParseLlmResponse": {
      "main": [
        [
          {
            "node": "StoreTrace",
            "type": "main",
            "index": 0
          },
          {
            "node": "UpdateNextPulse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "UpdateNextPulse": {
      "main": [
        []
      ]
    },
    "StoreTrace": {
      "main": [
        [
          {
            "node": "MergeTraceResult",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MergeTraceResult": {
      "main": [
        [
          {
            "node": "IfEmptyMessage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IfEmptyMessage": {
      "main": [
        [],
        [
          {
            "node": "StoreProjection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "StoreProjection": {
      "main": [
        [
          {
            "node": "MergeForDiscord",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MergeForDiscord": {
      "main": [
        [
          {
            "node": "SendMessage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SendMessage": {
      "main": [
        [
          {
            "node": "UpdateProjectionWithMessageId",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "UpdateProjectionWithMessageId": {
      "main": [
        [
          {
            "node": "AddDiagnosticReaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AddDiagnosticReaction": {
      "main": [
        [
          {
            "node": "CheckVerboseConfig",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CheckVerboseConfig": {
      "main": [
        [
          {
            "node": "IfVerbose?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IfVerbose?": {
      "main": [
        [],
        [
          {
            "node": "TriggerShowDetails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TriggerShowDetails": {
      "main": [
        []
      ]
    },
    "NemotronNano9b": {
      "ai_languageModel": [
        [
          {
            "node": "GenerateMessageWithLlm",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "MimoV2Flash": {
      "ai_languageModel": [
        [
          {
            "node": "GenerateMessageWithLlm",
            "type": "ai_languageModel",
            "index": 1
          }
        ]
      ]
    }
  },
  "settings": {
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "NOJ7FqVhVLqw0n8D",
    "availableInMCP": false,
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "active": false
}
