{
  "name": "Generate_Activity_Reminder",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 30
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        0,
        0
      ],
      "id": "cron-trigger",
      "name": "Every 30 Minutes"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH user_events AS (\n  SELECT \n    payload->>'author_login' as user_login,\n    MAX(received_at) as last_observation_at,\n    EXTRACT(EPOCH FROM (NOW() - MAX(received_at)))/60 as minutes_since_activity\n  FROM events\n  WHERE payload->>'author_login' IS NOT NULL\n  GROUP BY payload->>'author_login'\n),\nlatest_activity AS (\n  SELECT \n    ue.user_login,\n    ue.last_observation_at,\n    p.data->>'category' as last_category,\n    ue.minutes_since_activity\n  FROM user_events ue\n  LEFT JOIN projections p ON p.projection_type = 'activity' \n    AND p.data->>'timestamp' = (\n      SELECT MAX(data->>'timestamp') \n      FROM projections \n      WHERE projection_type = 'activity'\n    )\n  WHERE ue.last_observation_at IS NULL \n    OR ue.last_observation_at < NOW() - INTERVAL '30 minutes'\n  LIMIT 1\n)\nSELECT * \nFROM latest_activity\nWHERE last_category IS NULL OR last_category != 'sleep'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        224,
        0
      ],
      "id": "query-user-state",
      "name": "Check User State",
      "credentials": {
        "postgres": {
          "id": "MdnYzEgjzWRujz2v",
          "name": "Postgres account"
        }
      },
      "notes": "Checks if:\n1. User is awake (last activity != 'sleep')\n2. No activity in last 30 minutes\n\nAll state derived from events and projections.\nNo user_state table needed.\nIf conditions met, returns row and continues.\nIf not met, returns nothing and workflow stops."
    },
    {
      "parameters": {
        "jsCode": "// Prepare for event insertion\nconst userState = $json;\nconst now = new Date();\nconst idempotencyKey = `scheduled:activity_reminder:${now.toISOString().slice(0, 16)}`; // Per-minute granularity\n\nreturn [{\n  json: {\n    user_state: userState,\n    idempotency_key: idempotencyKey,\n    trigger_reason: 'cron'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        0
      ],
      "id": "prepare-event",
      "name": "Prepare Event"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Insert system_scheduled event for activity reminder\nINSERT INTO events (idempotency_key, event_type, payload)\nVALUES (\n  $1,\n  'system_scheduled',\n  jsonb_build_object(\n    'source_type', 'scheduler',\n    'trigger_type', 'activity_reminder',\n    'trigger_reason', $2,\n    'user_state', jsonb_build_object(\n      'last_observation_at', $3,\n      'last_category', $4,\n      'minutes_since_activity', $5\n    )\n  )\n)\nON CONFLICT (idempotency_key) DO UPDATE SET id = events.id\nRETURNING id;",
        "options": {
          "queryReplacement": "={{ $json.idempotency_key }},={{ $json.trigger_reason }},={{ $json.user_state.last_observation_at || null }},={{ $json.user_state.last_category || null }},={{ $json.user_state.minutes_since_activity || 0 }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        672,
        0
      ],
      "id": "insert-event",
      "name": "Insert Event",
      "credentials": {
        "postgres": {
          "id": "MdnYzEgjzWRujz2v",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Initialize ctx with event_id\nconst eventResult = $json;\nconst prepareData = $('Prepare Event').first().json;\n\nreturn [{\n  json: {\n    ctx: {\n      event: {\n        event_id: eventResult.id,\n        trigger_type: 'activity_reminder',\n        trigger_reason: prepareData.trigger_reason,\n        trace_chain: []\n      }\n    },\n    user_state: prepareData.user_state\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        896,
        0
      ],
      "id": "init-ctx",
      "name": "Initialize ctx"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- No LLM call for activity reminder, so create a minimal trace\n-- This records the system decision to send a reminder\nINSERT INTO traces (event_id, step_name, data, trace_chain)\nVALUES (\n  $1::uuid,\n  'activity_reminder',\n  jsonb_build_object(\n    'input', jsonb_build_object(\n      'user_state', $2::jsonb\n    ),\n    'result', jsonb_build_object(\n      'action', 'send_reminder',\n      'message', 'Activity check reminder sent'\n    ),\n    'duration_ms', 0\n  ),\n  '{}'::uuid[]\n)\nRETURNING id, ARRAY[id] AS updated_trace_chain;",
        "options": {
          "queryReplacement": "={{ $json.ctx.event.event_id }},={{ JSON.stringify($json.user_state || {}) }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1120,
        0
      ],
      "id": "store-trace",
      "name": "Store Trace",
      "credentials": {
        "postgres": {
          "id": "MdnYzEgjzWRujz2v",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare projection data with trace_id\nconst traceResult = $json;\nconst ctxData = $('Initialize ctx').first().json;\nconst ctx = ctxData.ctx;\n\nconst updatedTraceChain = traceResult.updated_trace_chain || [];\nconst updatedTraceChainPg = '{' + updatedTraceChain.join(',') + '}';\n\nconst reminderText = `**Activity Check**\\n\\nNo activity detected in the last 30 minutes.\\n\\nWhat are you currently working on?\\nReply with: \\`!! <what you're doing>\\``;\n\nreturn [{\n  json: {\n    ctx,\n    trace_id: traceResult.id,\n    trace_chain_pg: updatedTraceChainPg,\n    reminder_text: reminderText,\n    projection_data: {\n      timestamp: new Date().toISOString(),\n      text: reminderText,\n      user_state: ctxData.user_state\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1344,
        0
      ],
      "id": "prepare-projection",
      "name": "Prepare Projection"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO projections (trace_id, event_id, trace_chain, projection_type, data, status)\nVALUES (\n  $1::uuid,\n  $2::uuid,\n  $3::uuid[],\n  'activity_reminder',\n  $4::jsonb,\n  'auto_confirmed'\n)\nRETURNING id;",
        "options": {
          "queryReplacement": "={{ $json.trace_id }},={{ $json.ctx.event.event_id }},={{ $json.trace_chain_pg }},={{ JSON.stringify($json.projection_data) }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1568,
        0
      ],
      "id": "store-projection",
      "name": "Store Projection",
      "credentials": {
        "postgres": {
          "id": "MdnYzEgjzWRujz2v",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge projection result back for Discord\nconst projResult = $json;\nconst prepData = $('Prepare Projection').first().json;\n\nreturn [{\n  json: {\n    ctx: prepData.ctx,\n    projection_id: projResult.id,\n    reminder_text: prepData.reminder_text\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        0
      ],
      "id": "merge-for-discord",
      "name": "Merge for Discord"
    },
    {
      "parameters": {
        "resource": "message",
        "guildId": {
          "__rl": true,
          "value": "={{ $env.DISCORD_GUILD_ID }}",
          "mode": "id"
        },
        "channelId": {
          "__rl": true,
          "value": "={{ $env.DISCORD_CHANNEL_ARCANE_SHELL }}",
          "mode": "id"
        },
        "content": "={{ $json.reminder_text }}",
        "options": {}
      },
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        2016,
        0
      ],
      "id": "send-reminder",
      "name": "Send Activity Reminder",
      "credentials": {
        "discordBotApi": {
          "id": "hvetTjtpeKFB1V0I",
          "name": "Discord Bot account"
        }
      },
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Update projection with Discord message ID for void support\nUPDATE projections \nSET data = data || jsonb_build_object(\n  'discord_message_id', $1,\n  'discord_channel_id', $2,\n  'discord_guild_id', $3\n)\nWHERE id = $4::uuid\nRETURNING id;",
        "options": {
          "queryReplacement": "={{ $json.id }},={{ $env.DISCORD_CHANNEL_ARCANE_SHELL }},={{ $env.DISCORD_GUILD_ID }},={{ $('Merge for Discord').first().json.projection_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        2240,
        0
      ],
      "id": "update-projection-message-id",
      "name": "Update Projection with Message ID",
      "credentials": {
        "postgres": {
          "id": "MdnYzEgjzWRujz2v",
          "name": "Postgres account"
        }
      }
    }
  ],
  "connections": {
    "Every 30 Minutes": {
      "main": [
        [
          {
            "node": "Check User State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check User State": {
      "main": [
        [
          {
            "node": "Prepare Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Event": {
      "main": [
        [
          {
            "node": "Insert Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Event": {
      "main": [
        [
          {
            "node": "Initialize ctx",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize ctx": {
      "main": [
        [
          {
            "node": "Store Trace",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Trace": {
      "main": [
        [
          {
            "node": "Prepare Projection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Projection": {
      "main": [
        [
          {
            "node": "Store Projection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Projection": {
      "main": [
        [
          {
            "node": "Merge for Discord",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge for Discord": {
      "main": [
        [
          {
            "node": "Send Activity Reminder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Activity Reminder": {
      "main": [
        [
          {
            "node": "Update Projection with Message ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "timeSavedMode": "fixed",
    "errorWorkflow": "JOXLqn9TTznBdo7Q"
  },
  "staticData": {
    "node:Every 30 Minutes": {
      "recurrenceRules": []
    }
  },
  "meta": null,
  "active": false
}
