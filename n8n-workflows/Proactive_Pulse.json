{
  "updatedAt": "2025-12-24T08:53:15.162Z",
  "createdAt": "2025-12-23T09:30:30.116Z",
  "id": "lnxlZ8AFe7LhMMEA",
  "name": "Proactive_Pulse",
  "description": "Proactive agent that generates contextual messages - tested",
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 5
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        0,
        -400
      ],
      "id": "schedule-trigger-pulse",
      "name": "Every5Minutes"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Get next_pulse timestamp and current time\nSELECT \n  COALESCE(\n    (SELECT value::timestamptz FROM config WHERE key = 'next_pulse'),\n    NOW() - INTERVAL '1 minute'\n  ) as next_pulse,\n  NOW() as current_time,\n  COALESCE(\n    (SELECT value::timestamptz FROM config WHERE key = 'next_pulse'),\n    NOW() - INTERVAL '1 minute'\n  ) <= NOW() as should_run;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        224,
        -400
      ],
      "id": "check-next-pulse-timing",
      "name": "CheckNextPulse",
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "check-should-run-condition",
              "leftValue": "={{ $json.should_run }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        448,
        -400
      ],
      "id": "should-run-check",
      "name": "ShouldRunPulse?"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Use advisory lock to prevent concurrent executions\nSELECT pg_advisory_xact_lock(hashtext('proactive_pulse'));\n\n-- Update next_pulse with recheck to prevent race condition\nUPDATE config \nSET value = (NOW() + INTERVAL '2 hours')::text, updated_at = NOW()\nWHERE key = 'next_pulse'\n  AND (value::timestamptz IS NULL OR value::timestamptz <= NOW())\nRETURNING value;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        672,
        -480
      ],
      "id": "set-default-next-pulse",
      "name": "SetDefaultNextPulse",
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare data from schedule trigger\nreturn {\n  json: {\n    trigger_reason: 'cron'\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        896,
        -480
      ],
      "id": "prepare-cron-trigger-data",
      "name": "PrepareCronData"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        0,
        0
      ],
      "id": "workflow-trigger",
      "name": "WhenCalledByAnotherWorkflow"
    },
    {
      "parameters": {
        "jsCode": "// Extract trigger_reason from caller, default to 'cron'\nconst input = $json;\nconst triggerReason = input.trigger_reason || 'cron';\nconst now = new Date();\nconst idempotencyKey = `scheduled:proactive:${now.toISOString().slice(0, 16)}:${triggerReason}`;\n\nreturn {\n  json: {\n    idempotency_key: idempotencyKey,\n    trigger_reason: triggerReason,\n    timestamp: now.toISOString()\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1568,
        0
      ],
      "id": "prepare-event",
      "name": "PrepareEvent"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Insert system event for proactive agent\nINSERT INTO events (idempotency_key, event_type, payload, timezone)\nVALUES (\n  $1,\n  'system',\n  jsonb_build_object(\n    'trigger_type', 'proactive_agent',\n    'trigger_reason', $2,\n    'timestamp', $3\n  ),\n  COALESCE((SELECT value FROM config WHERE key = 'timezone'), 'UTC')\n)\nON CONFLICT (event_type, idempotency_key) DO UPDATE SET id = events.id, timezone = EXCLUDED.timezone\nRETURNING id, timezone, payload->>'trigger_reason' as trigger_reason, payload->>'timestamp' as timestamp;",
        "options": {
          "values": "{{ $json.idempotency_key }},{{ $json.trigger_reason }},{{ $json.timestamp }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        1792,
        0
      ],
      "id": "insert-event",
      "name": "InsertEvent",
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Initialize ctx with event_id and prepare all queries for Execute_Queries\nconst eventResult = $json;\n\nreturn {\n  json: {\n    ctx: {\n      event: {\n        event_id: eventResult.id,\n        trigger_type: 'proactive_agent',\n        trigger_reason: eventResult.trigger_reason,\n        timestamp: eventResult.timestamp,\n        timezone: eventResult.timezone || 'UTC',\n        trace_chain: [eventResult.id],\n        trace_chain_pg: `{${eventResult.id}}`\n      },\n      db_queries: [\n        {\n          key: 'prompt_modules',\n          sql: `SELECT id, name, content, module_type, tags, priority\n                FROM prompt_modules\n                WHERE active = true\n                ORDER BY priority ASC;`,\n          params: []\n        },\n        {\n          key: 'north_star',\n          sql: `SELECT value FROM config WHERE key = 'north_star';`,\n          params: []\n        },\n        {\n          key: 'recent_activities',\n          sql: `SELECT \n                  (p.data->>'timestamp')::timestamptz as timestamp,\n                  p.data->>'category' as category,\n                  p.data->>'description' as description\n                FROM projections p\n                WHERE p.projection_type = 'activity'\n                  AND p.status IN ('auto_confirmed', 'confirmed')\n                  AND (p.data->>'timestamp')::timestamptz >= NOW() - INTERVAL '24 hours'\n                ORDER BY (p.data->>'timestamp')::timestamptz DESC\n                LIMIT 20;`,\n          params: []\n        },\n        {\n          key: 'recent_notes',\n          sql: `SELECT \n                  (p.data->>'timestamp')::timestamptz as timestamp,\n                  p.data->>'category' as category,\n                  p.data->>'text' as text\n                FROM projections p\n                WHERE p.projection_type = 'note'\n                  AND p.status IN ('auto_confirmed', 'confirmed')\n                  AND (p.data->>'timestamp')::timestamptz >= NOW() - INTERVAL '7 days'\n                ORDER BY (p.data->>'timestamp')::timestamptz DESC\n                LIMIT 5;`,\n          params: []\n        },\n        {\n          key: 'pending_todos',\n          sql: `SELECT \n                  p.id,\n                  p.data->>'text' as text,\n                  p.data->>'status' as status,\n                  p.created_at,\n                  EXTRACT(DAY FROM NOW() - p.created_at) as days_pending\n                FROM projections p\n                WHERE p.projection_type = 'todo'\n                  AND p.status IN ('auto_confirmed', 'confirmed')\n                  AND COALESCE(p.data->>'status', 'pending') = 'pending'\n                ORDER BY p.created_at ASC\n                LIMIT 10;`,\n          params: []\n        }\n      ]\n    }\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2016,
        0
      ],
      "id": "init-ctx",
      "name": "InitializeCtx"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "CgUAxK0i4YhrZ2Wp",
          "mode": "list",
          "cachedResultName": "Execute_Queries",
          "cachedResultUrl": "/workflow/CgUAxK0i4YhrZ2Wp"
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        2240,
        0
      ],
      "id": "execute-queries",
      "name": "ExecuteQueries"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build context summary for semantic module selection from ctx.db results\nconst ctx = $json.ctx;\n\nif (!ctx?.db) {\n  throw new Error('ctx.db not found - Execute_Queries must run first');\n}\n\n// Extract query results from ctx.db\nconst promptModules = ctx.db.prompt_modules?.rows || [];\nconst activities = ctx.db.recent_activities?.rows || [];\nconst notes = ctx.db.recent_notes?.rows || [];\nconst todos = ctx.db.pending_todos?.rows || [];\nconst northStar = ctx.db.north_star?.row?.value || null;\n\n// Extract technique modules for semantic selection\nconst techniques = promptModules\n  .filter(m => m.module_type === 'technique')\n  .map(m => m.content);\n\n// Check for stuck todos (pending > 3 days)\nconst stuckTodos = todos.filter(t => t.days_pending > 3);\n\n// Build a context summary for semantic search\nconst summaryParts = [];\n\nif (activities.length > 0) {\n  const recentActivities = activities.slice(0, 3).map(a => a.description).join(', ');\n  summaryParts.push(`Recent activities: ${recentActivities}`);\n}\n\nif (notes.length > 0) {\n  const recentNotes = notes.slice(0, 2).map(n => n.text.substring(0, 100)).join('; ');\n  summaryParts.push(`Notes: ${recentNotes}`);\n}\n\nif (stuckTodos.length > 0) {\n  summaryParts.push(`Stuck todos: ${stuckTodos.map(t => t.text).join(', ')}`);\n} else if (todos.length > 0) {\n  summaryParts.push(`Pending todos: ${todos.slice(0, 3).map(t => t.text).join(', ')}`);\n}\n\nif (summaryParts.length === 0) {\n  summaryParts.push('No recent activity logged. User may need a gentle check-in.');\n}\n\nconst contextSummary = summaryParts.join('. ');\n\n// Return context summary with all needed data\nreturn {\n  json: {\n    ctx,\n    context_summary: contextSummary,\n    technique_candidates: techniques,\n    has_stuck_todos: stuckTodos.length > 0,\n    has_activities: activities.length > 0,\n    has_notes: notes.length > 0,\n    prompt_modules: promptModules,\n    activities,\n    notes,\n    todos,\n    north_star: northStar\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2688,
        0
      ],
      "id": "build-context-summary",
      "name": "BuildContextSummary"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.EMBEDDING_SERVICE_URL }}/search",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"query\": {{ JSON.stringify($json.context_summary) }},\n  \"table\": \"prompt_modules\",\n  \"filter\": {\"module_type\": \"technique\"},\n  \"top_k\": 1\n}",
        "options": {
          "timeout": 10000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2912,
        0
      ],
      "id": "semantic-select-techniques",
      "name": "SemanticSelectTechniques",
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.EMBEDDING_SERVICE_URL }}/embed",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"texts\": [{{ JSON.stringify($json.context_summary) }}]\n}",
        "options": {
          "timeout": 10000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2912,
        192
      ],
      "id": "embed-context-for-rag",
      "name": "EmbedContextForRag",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Prepare embedding for pgvector query\nconst contextData = $('BuildContextSummary').first().json;\nconst embedResult = $json;\n\n// Extract the embedding vector\nlet embedding = null;\nif (embedResult.embeddings && embedResult.embeddings.length > 0) {\n  embedding = embedResult.embeddings[0];\n}\n\n// Format as pgvector array string\nlet embeddingPg = null;\nif (embedding) {\n  embeddingPg = '[' + embedding.join(',') + ']';\n}\n\nreturn {\n  json: {\n    ctx: contextData.ctx,\n    context_summary: contextData.context_summary,\n    all_items: contextData.all_items,\n    embedding_pg: embeddingPg,\n    has_embedding: embedding !== null\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3136,
        192
      ],
      "id": "prepare-embedding-for-rag",
      "name": "PrepareEmbeddingForRag"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- RAG: Find similar projections using pgvector\nSELECT \n  p.projection_type,\n  COALESCE(p.data->>'description', p.data->>'text') as content,\n  p.data->>'category' as category,\n  (p.data->>'timestamp')::timestamptz as timestamp,\n  e.embedding <=> $1::vector as distance\nFROM embeddings e\nJOIN projections p ON e.projection_id = p.id\nWHERE p.status IN ('auto_confirmed', 'confirmed')\n  AND p.created_at > NOW() - INTERVAL '30 days'\n  AND p.projection_type IN ('activity', 'note')\n  AND e.embedding IS NOT NULL\nORDER BY e.embedding <=> $1::vector\nLIMIT 5;",
        "options": {
          "values": "{{ $json.embedding_pg }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        3360,
        192
      ],
      "id": "rag-similar-projections",
      "name": "RagSimilarProjections",
      "alwaysOutputData": true,
      "continueOnFail": true,
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "mode": "append",
        "numberInputs": 2
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        3136,
        96
      ],
      "id": "merge-semantic-results",
      "name": "MergeSemanticResults"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Assemble prompt from modules and context with semantic selection\nconst allItems = $input.all();\n\n// Find the context summary item from BuildContextSummary\nlet contextData = null;\nfor (const item of allItems) {\n  if (item.json.ctx && item.json.context_summary) {\n    contextData = item.json;\n    break;\n  }\n}\n\nif (!contextData) {\n  throw new Error('Context data not found in merged items');\n}\n\nconst ctx = contextData.ctx;\nconst timezone = ctx.event.timezone || 'UTC';\n\n// Extract semantic selection results from MergeSemanticResults\nlet semanticMatches = [];\nfor (const item of allItems) {\n  if (item.json.results) {\n    semanticMatches = item.json.results;\n    break;\n  }\n}\n\n// Extract RAG results (similar projections) from RagSimilarProjections\nlet ragResults = [];\nfor (const item of allItems) {\n  if (item.json.projection_type !== undefined && item.json.distance !== undefined) {\n    ragResults.push(item.json);\n  }\n}\n\n// Get data from BuildContextSummary\nconst promptModules = contextData.prompt_modules || [];\nconst activities = contextData.activities || [];\nconst notes = contextData.notes || [];\nconst todos = contextData.todos || [];\nconst northStar = contextData.north_star || null;\n\n// Helper to format time in user's timezone\nconst formatTime = (isoString) => {\n  try {\n    return new Date(isoString).toLocaleTimeString('en-US', { \n      timeZone: timezone, \n      hour: 'numeric', \n      minute: '2-digit' \n    });\n  } catch (e) {\n    return new Date(isoString).toLocaleTimeString('en-US', { \n      hour: 'numeric', \n      minute: '2-digit' \n    });\n  }\n};\n\nconst formatDate = (isoString) => {\n  try {\n    return new Date(isoString).toLocaleDateString('en-US', { \n      timeZone: timezone, \n      weekday: 'short',\n      month: 'short', \n      day: 'numeric' \n    });\n  } catch (e) {\n    return new Date(isoString).toLocaleDateString('en-US', { \n      weekday: 'short',\n      month: 'short', \n      day: 'numeric' \n    });\n  }\n};\n\n// Get current hour in user's timezone\nconst now = new Date();\nlet currentHour;\ntry {\n  currentHour = parseInt(now.toLocaleTimeString('en-US', { \n    timeZone: timezone, \n    hour: 'numeric', \n    hour12: false \n  }));\n} catch (e) {\n  currentHour = now.getHours();\n}\n\n// Determine time of day for fallback technique selection\nconst isMorning = currentHour >= 6 && currentHour <= 9;\nconst isEvening = currentHour >= 20 && currentHour <= 23;\n\n// Get technique modules for context adaptation\nconst techniqueModules = promptModules.filter(m => m.module_type === 'technique');\n\n// Select technique: semantic match > time-based fallback > first available\nlet selectedTechnique = null;\nlet techniqueSource = 'none';\n\nif (semanticMatches && semanticMatches.length > 0 && semanticMatches[0].content) {\n  selectedTechnique = semanticMatches[0].content;\n  techniqueSource = `semantic_${semanticMatches[0].name || 'unknown'}`;\n} else if (techniqueModules.length > 0) {\n  // Time-based fallback\n  if (isMorning && techniqueModules.find(t => t.tags?.includes('morning'))) {\n    selectedTechnique = techniqueModules.find(t => t.tags?.includes('morning')).content;\n    techniqueSource = 'fallback_morning';\n  } else if (isEvening && techniqueModules.find(t => t.tags?.includes('evening'))) {\n    selectedTechnique = techniqueModules.find(t => t.tags?.includes('evening')).content;\n    techniqueSource = 'fallback_evening';\n  } else {\n    // Use first available technique\n    selectedTechnique = techniqueModules[0].content;\n    techniqueSource = 'fallback_first';\n  }\n}\n\n// Build context description for human-readable trace\nconst contextDescParts = [];\nif (contextData.has_stuck_todos) contextDescParts.push('stuck todos');\nif (contextData.has_activities) contextDescParts.push('recent activities');\nif (contextData.has_notes) contextDescParts.push('recent notes');\nconst contextDescription = contextDescParts.length > 0 \n  ? contextDescParts.join(', ')\n  : 'no recent activity';\n\n// Assemble prompt sections\nconst promptSections = [];\n\n// 1. System instruction\nconst systemModules = promptModules.filter(m => m.module_type === 'system');\nif (systemModules.length > 0) {\n  promptSections.push('# System Instructions\\n\\n' + systemModules.map(m => m.content).join('\\n\\n'));\n}\n\n// 2. North star (if configured)\nif (northStar) {\n  promptSections.push(`# Your North Star\\n\\n${northStar}`);\n}\n\n// 3. Selected technique (if available)\nif (selectedTechnique) {\n  promptSections.push(`# Technique for This Context\\n\\n${selectedTechnique}`);\n}\n\n// 4. RAG context (similar past projections)\nif (ragResults.length > 0) {\n  const ragSection = '# Related Past Activities\\n\\n' + \n    ragResults.map(r => {\n      const timestamp = formatDate(r.timestamp);\n      return `- ${timestamp}: ${r.content} (${r.category || 'uncategorized'})`;\n    }).join('\\n');\n  promptSections.push(ragSection);\n}\n\n// 5. Recent activities\nif (activities.length > 0) {\n  const activitySection = '# Recent Activities (Last 24h)\\n\\n' +\n    activities.map(a => {\n      const time = formatTime(a.timestamp);\n      return `- ${time}: ${a.description} (${a.category || 'uncategorized'})`;\n    }).join('\\n');\n  promptSections.push(activitySection);\n}\n\n// 6. Recent notes\nif (notes.length > 0) {\n  const noteSection = '# Recent Notes (Last 7 days)\\n\\n' +\n    notes.map(n => {\n      const date = formatDate(n.timestamp);\n      return `- ${date}: ${n.text}`;\n    }).join('\\n');\n  promptSections.push(noteSection);\n}\n\n// 7. Pending todos\nif (todos.length > 0) {\n  const todoSection = '# Pending Todos\\n\\n' +\n    todos.map(t => {\n      const daysPending = Math.floor(t.days_pending);\n      const urgency = daysPending > 3 ? ' \u26a0\ufe0f STUCK' : '';\n      return `- ${t.text} (${daysPending} days pending)${urgency}`;\n    }).join('\\n');\n  promptSections.push(todoSection);\n}\n\n// 8. Current context\nconst currentTime = now.toLocaleString('en-US', { \n  timeZone: timezone,\n  weekday: 'long',\n  month: 'long',\n  day: 'numeric',\n  hour: 'numeric',\n  minute: '2-digit'\n});\npromptSections.push(`# Current Context\\n\\nTime: ${currentTime}\\nTimezone: ${timezone}`);\n\n// Assemble final prompt\nconst assembledPrompt = promptSections.join('\\n\\n---\\n\\n');\n\n// Build input summary for trace storage\nconst inputSummary = {\n  activities_count: activities.length,\n  notes_count: notes.length,\n  todos_count: todos.length,\n  stuck_todos_count: todos.filter(t => t.days_pending > 3).length,\n  has_north_star: !!northStar,\n  technique_source: techniqueSource,\n  rag_matches: ragResults.length\n};\n\nreturn {\n  json: {\n    ctx,\n    assembled_prompt: assembledPrompt,\n    context_description: contextDescription,\n    technique_source: techniqueSource,\n    input_summary: inputSummary\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3360,
        96
      ],
      "id": "assemble-prompt",
      "name": "AssemblePrompt"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.assembled_prompt }}\n\n---\n\n## Your Task\n\nBased on the context above, compose a proactive message to the user. This is a {{ $json.context_description }}.\n\nYour message should be helpful, personal, and timely. Reference their specific activities, notes, or todos when relevant.\n\nRespond with ONLY the message you would send to the user. No preamble, no explanation - just the message itself.",
        "needsFallback": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        3584,
        96
      ],
      "id": "generate-message-llm",
      "name": "GenerateMessageWithLlm"
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM response\nconst llmText = $json.text?.trim() || '';\nconst ctx = $json.ctx;\nconst llmMetadata = ctx.llm || {};\nconst durationMs = Date.now() - (llmMetadata.inference_start || Date.now());\n\nlet message = '';\nlet nextPulseMinutes = 120; // Default: 2 hours (range: 30min-24h)\nlet reasoning = '';\nlet parseFailed = false;\n\ntry {\n  // Extract JSON from response (handling potential markdown blocks)\n  const jsonMatch = llmText.match(/\\{[\\s\\S]*\\}/);\n  const data = JSON.parse(jsonMatch ? jsonMatch[0] : llmText);\n  message = data.message || '';\n  nextPulseMinutes = Math.max(30, Math.min(1440, parseInt(data.next_pulse_minutes) || 120));\n  reasoning = data.reasoning || '';\n} catch (e) {\n  // Fallback for non-JSON or malformed responses\n  message = llmText.replace(/^```[a-z]*\\n?/, '').replace(/\\n?```$/, '').trim();\n  parseFailed = true;\n}\n\n// Check if message is empty or too short\nconst isEmpty = !message || message.length < 10;\n\nreturn {\n  json: {\n    ctx,\n    message: message,\n    next_pulse_minutes: nextPulseMinutes,\n    parse_failed: parseFailed,\n    reasoning: reasoning,\n    is_empty: isEmpty,\n    duration_ms: durationMs,\n    trace_chain_pg: llmMetadata.trace_chain_pg,\n    llm_response: llmText,\n    assembled_prompt: llmMetadata.assembled_prompt,\n    context_description: llmMetadata.context_description,\n    technique_source: llmMetadata.technique_source,\n    input_summary: llmMetadata.input_summary\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3808,
        96
      ],
      "id": "parse-llm-response",
      "name": "ParseLlmResponse"
    },
    {
      "parameters": {
        "jsCode": "// Prepare db_queries for Execute_Queries: trace \u2192 projection \u2192 update\nconst ctx = $json.ctx;\nconst eventId = ctx.event.event_id;\nconst traceChainPg = ctx.event.trace_chain_pg;\nconst timezone = ctx.event.timezone || 'UTC';\n\n// Pre-stringify projection data for Postgres\nconst projectionData = {\n  timestamp: new Date().toISOString(),\n  text: $json.message,\n  context_description: $json.context_description,\n  technique_source: $json.technique_source\n};\n\nreturn {\n  json: {\n    ctx: {\n      ...ctx,\n      db_queries: [\n        {\n          key: 'trace',\n          sql: `INSERT INTO traces (event_id, step_name, data, trace_chain)\n                VALUES ($1::uuid, 'proactive_agent', $2::jsonb, $3::uuid[])\n                RETURNING id, trace_chain || id AS updated_trace_chain`,\n          params: [\n            eventId,\n            JSON.stringify({\n              prompt: $json.assembled_prompt,\n              completion: $json.llm_response,\n              context_description: $json.context_description,\n              technique_source: $json.technique_source,\n              input_summary: $json.input_summary,\n              duration_ms: $json.duration_ms\n            }),\n            traceChainPg\n          ]\n        },\n        {\n          key: 'projection',\n          sql: `INSERT INTO projections (trace_id, event_id, trace_chain, projection_type, data, status, timezone)\n                VALUES ($1::uuid, $2::uuid, $3::uuid[], 'pulse', $4::jsonb, 'auto_confirmed', $5)\n                RETURNING id`,\n          params: [\n            '$results.trace.row.id',\n            eventId,\n            '$results.trace.row.updated_trace_chain',\n            JSON.stringify(projectionData),\n            timezone\n          ]\n        }\n      ],\n      // Pass through data needed after Execute_Queries\n      temp: {\n        message: $json.message,\n        is_empty: $json.is_empty\n      }\n    }\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4256,
        96
      ],
      "id": "prepare-db-queries",
      "name": "PrepareDbQueries"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "check-empty",
              "leftValue": "={{ $json.is_empty }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        4480,
        96
      ],
      "id": "if-empty",
      "name": "IfEmptyMessage"
    },
    {
      "parameters": {
        "resource": "message",
        "guildId": {
          "__rl": true,
          "value": "={{ $env.DISCORD_GUILD_ID }}",
          "mode": "id"
        },
        "channelId": {
          "__rl": true,
          "value": "={{ $env.DISCORD_CHANNEL_ARCANE_SHELL }}",
          "mode": "id"
        },
        "content": "={{ $json.message }}",
        "options": {}
      },
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        5152,
        176
      ],
      "id": "send-message",
      "name": "SendMessage",
      "credentials": {
        "discordBotApi": {
          "id": "HzhURrgtJQZuwPMZ",
          "name": "Discord Bot account"
        }
      },
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE config \nSET value = (NOW() + ($1 || ' minutes')::interval)::text, updated_at = NOW()\nWHERE key = 'next_pulse';",
        "options": {
          "values": "={{ $json.next_pulse_minutes }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        4032,
        288
      ],
      "id": "update-next-pulse",
      "name": "UpdateNextPulse",
      "credentials": {
        "postgres": {
          "id": "GIpVtzgs3wiCmQBQ",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Restore ctx from AssemblePrompt after LLM call\nconst llmOutput = $json;\nconst assembleData = $('AssemblePrompt').first().json;\n\nreturn {\n  json: {\n    ...llmOutput,\n    ctx: assembleData.ctx\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3808,
        96
      ],
      "id": "acebb70878994681",
      "name": "RestoreCtx"
    },
    {
      "parameters": {
        "jsCode": "// Prepare db_queries for Execute_Queries: trace \u2192 projection\nconst ctx = $json.ctx;\nconst eventId = ctx.event.event_id;\nconst traceChainPg = ctx.event.trace_chain_pg;\nconst timezone = ctx.event.timezone || 'UTC';\n\n// Pre-stringify projection data for Postgres\nconst projectionData = {\n  timestamp: new Date().toISOString(),\n  text: $json.message,\n  context_description: $json.context_description,\n  technique_source: $json.technique_source\n};\n\nreturn {\n  json: {\n    ctx: {\n      ...ctx,\n      db_queries: [\n        {\n          key: 'trace',\n          sql: `INSERT INTO traces (event_id, step_name, data, trace_chain)\n                VALUES ($1::uuid, 'proactive_agent', $2::jsonb, $3::uuid[])\n                RETURNING id, trace_chain || id AS updated_trace_chain`,\n          params: [\n            eventId,\n            JSON.stringify({\n              prompt: $json.assembled_prompt,\n              completion: $json.llm_response,\n              context_description: $json.context_description,\n              technique_source: $json.technique_source,\n              input_summary: $json.input_summary,\n              duration_ms: $json.duration_ms\n            }),\n            traceChainPg\n          ]\n        },\n        {\n          key: 'projection',\n          sql: `INSERT INTO projections (trace_id, event_id, trace_chain, projection_type, data, status, timezone)\n                VALUES ($1::uuid, $2::uuid, $3::uuid[], 'pulse', $4::jsonb, 'auto_confirmed', $5)\n                RETURNING id`,\n          params: [\n            '$results.trace.row.id',\n            eventId,\n            '$results.trace.row.updated_trace_chain',\n            JSON.stringify(projectionData),\n            timezone\n          ]\n        }\n      ],\n      // Pass through data needed after Execute_Queries\n      temp: {\n        message: $json.message,\n        is_empty: $json.is_empty\n      }\n    }\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4256,
        96
      ],
      "id": "prepare-db-queries",
      "name": "PrepareDbQueries"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "CgUAxK0i4YhrZ2Wp",
          "mode": "list",
          "cachedResultName": "Execute_Queries",
          "cachedResultUrl": "/workflow/CgUAxK0i4YhrZ2Wp"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "ctx": "={{ $json.ctx }}"
          }
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        4480,
        96
      ],
      "id": "store-trace-and-projection",
      "name": "StoreTraceAndProjection"
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for Discord and additional updates\nconst ctx = $json.ctx;\nconst message = ctx.temp?.message || '';\nconst isEmpty = ctx.temp?.is_empty || false;\nconst projectionId = ctx.db?.projection?.row?.id;\n\nreturn {\n  json: {\n    ctx: {\n      ...ctx,\n      // Clean up temp namespace\n      temp: undefined\n    },\n    message: message,\n    is_empty: isEmpty,\n    projection_id: projectionId\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4704,
        96
      ],
      "id": "prepare-for-discord",
      "name": "PrepareForDiscord"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Discord message ID update query\nconst discordResult = $json;\nconst prepData = $('PrepareForDiscord').first().json;\nconst ctx = prepData.ctx;\n\nreturn {\n  json: {\n    ctx: {\n      ...ctx,\n      db_queries: [{\n        key: 'update_projection',\n        sql: `UPDATE projections \n              SET data = data || jsonb_build_object(\n                'discord_message_id', $1,\n                'discord_channel_id', $2,\n                'discord_guild_id', $3\n              )\n              WHERE id = $4::uuid\n              RETURNING id`,\n        params: [\n          discordResult.id,\n          $env.DISCORD_CHANNEL_ARCANE_SHELL,\n          $env.DISCORD_GUILD_ID,\n          prepData.projection_id\n        ]\n      }]\n    }\n  }\n};",
        "mode": "runOnceForEachItem"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5376,
        176
      ],
      "id": "prepare-discord-update",
      "name": "PrepareDiscordUpdate"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "CgUAxK0i4YhrZ2Wp",
          "mode": "list",
          "cachedResultName": "Execute_Queries",
          "cachedResultUrl": "/workflow/CgUAxK0i4YhrZ2Wp"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "ctx": "={{ $json.ctx }}"
          }
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        5600,
        176
      ],
      "id": "update-projection-with-message-id",
      "name": "UpdateProjectionWithMessageId"
    }
  ],
  "connections": {
    "WhenCalledByAnotherWorkflow": {
      "main": [
        [
          {
            "node": "PrepareEvent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PrepareEvent": {
      "main": [
        [
          {
            "node": "InsertEvent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "InsertEvent": {
      "main": [
        [
          {
            "node": "InitializeCtx",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "InitializeCtx": {
      "main": [
        [
          {
            "node": "ExecuteQueries",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ExecuteQueries": {
      "main": [
        [
          {
            "node": "BuildContextSummary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BuildContextSummary": {
      "main": [
        [
          {
            "node": "SemanticSelectTechniques",
            "type": "main",
            "index": 0
          },
          {
            "node": "EmbedContextForRag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "EmbedContextForRag": {
      "main": [
        [
          {
            "node": "PrepareEmbeddingForRag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PrepareEmbeddingForRag": {
      "main": [
        [
          {
            "node": "RagSimilarProjections",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SemanticSelectTechniques": {
      "main": [
        [
          {
            "node": "MergeSemanticResults",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RagSimilarProjections": {
      "main": [
        [
          {
            "node": "MergeSemanticResults",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "MergeSemanticResults": {
      "main": [
        [
          {
            "node": "AssemblePrompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AssemblePrompt": {
      "main": [
        [
          {
            "node": "GenerateMessageWithLlm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GenerateMessageWithLlm": {
      "main": [
        [
          {
            "node": "RestoreCtx",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ParseLlmResponse": {
      "main": [
        [
          {
            "node": "PrepareDbQueries",
            "type": "main",
            "index": 0
          },
          {
            "node": "UpdateNextPulse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "UpdateNextPulse": {
      "main": [
        []
      ]
    },
    "IfEmptyMessage": {
      "main": [
        [],
        [
          {
            "node": "SendMessage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SendMessage": {
      "main": [
        [
          {
            "node": "PrepareDiscordUpdate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Every5Minutes": {
      "main": [
        [
          {
            "node": "CheckNextPulse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CheckNextPulse": {
      "main": [
        [
          {
            "node": "ShouldRunPulse?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ShouldRunPulse?": {
      "main": [
        [
          {
            "node": "SetDefaultNextPulse",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "SetDefaultNextPulse": {
      "main": [
        [
          {
            "node": "PrepareCronData",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PrepareCronData": {
      "main": [
        [
          {
            "node": "PrepareEvent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RestoreCtx": {
      "main": [
        [
          {
            "node": "ParseLlmResponse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PrepareDbQueries": {
      "main": [
        [
          {
            "node": "StoreTraceAndProjection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "StoreTraceAndProjection": {
      "main": [
        [
          {
            "node": "PrepareForDiscord",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PrepareForDiscord": {
      "main": [
        [
          {
            "node": "IfEmptyMessage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PrepareDiscordUpdate": {
      "main": [
        [
          {
            "node": "UpdateProjectionWithMessageId",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "NOJ7FqVhVLqw0n8D",
    "availableInMCP": false,
    "executionOrder": "v1"
  },
  "staticData": {
    "node:Every5Minutes": {
      "recurrenceRules": []
    }
  },
  "meta": null,
  "versionId": "32fe7d6b-15d0-40be-903b-62dd17616204",
  "activeVersionId": null,
  "versionCounter": 166,
  "triggerCount": 2,
  "shared": [
    {
      "updatedAt": "2025-12-23T09:30:30.116Z",
      "createdAt": "2025-12-23T09:30:30.116Z",
      "role": "workflow:owner",
      "workflowId": "lnxlZ8AFe7LhMMEA",
      "projectId": "erM3nntdLL53noWi",
      "project": {
        "updatedAt": "2025-12-23T09:23:39.658Z",
        "createdAt": "2025-12-23T09:16:56.460Z",
        "id": "erM3nntdLL53noWi",
        "name": "Chris Irineo <chriskevini@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "projectRelations": [
          {
            "updatedAt": "2025-12-23T09:16:56.460Z",
            "createdAt": "2025-12-23T09:16:56.460Z",
            "userId": "2a851a2d-b7e5-4b3c-aefb-6eaaa79e0659",
            "projectId": "erM3nntdLL53noWi",
            "user": {
              "updatedAt": "2025-12-24T08:40:46.063Z",
              "createdAt": "2025-12-23T09:16:54.881Z",
              "id": "2a851a2d-b7e5-4b3c-aefb-6eaaa79e0659",
              "email": "chriskevini@gmail.com",
              "firstName": "Chris",
              "lastName": "Irineo",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2025-12-23T09:23:43.723Z",
                "personalization_survey_n8n_version": "1.123.5"
              },
              "settings": {
                "userActivated": true,
                "firstSuccessfulWorkflowId": "CgUAxK0i4YhrZ2Wp",
                "userActivatedAt": 1766487000077,
                "easyAIWorkflowOnboarded": true
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2025-12-24",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": null
}